{
  "__inputs": [
    {
      "name": "DS_INFLUXDB",
      "label": "influxdb",
      "description": "",
      "type": "datasource",
      "pluginId": "influxdb",
      "pluginName": "InfluxDB"
    }
  ],
  "__elements": {},
  "__requires": [
    {
      "type": "panel",
      "id": "bargauge",
      "name": "Bar gauge",
      "version": ""
    },
    {
      "type": "panel",
      "id": "gauge",
      "name": "Gauge",
      "version": ""
    },
    {
      "type": "grafana",
      "id": "grafana",
      "name": "Grafana",
      "version": "12.1.0"
    },
    {
      "type": "datasource",
      "id": "influxdb",
      "name": "InfluxDB",
      "version": "1.0.0"
    },
    {
      "type": "panel",
      "id": "stat",
      "name": "Stat",
      "version": ""
    },
    {
      "type": "panel",
      "id": "text",
      "name": "Text",
      "version": ""
    },
    {
      "type": "panel",
      "id": "timeseries",
      "name": "Time series",
      "version": ""
    }
  ],
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": {
          "type": "datasource",
          "uid": "grafana"
        },
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "target": {
          "limit": 100,
          "matchAny": false,
          "tags": [],
          "type": "dashboard"
        },
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 0,
  "id": null,
  "links": [],
  "panels": [
    {
      "collapsed": false,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 0
      },
      "id": 185,
      "panels": [],
      "title": "System monitoring",
      "type": "row"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "none"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 3,
        "w": 3,
        "x": 0,
        "y": 1
      },
      "id": 58,
      "maxDataPoints": 100,
      "options": {
        "colorMode": "none",
        "graphMode": "none",
        "justifyMode": "auto",
        "orientation": "horizontal",
        "percentChangeColorMode": "standard",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showPercentChange": false,
        "textMode": "auto",
        "wideLayout": true
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "num_threads_RDB"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Cores",
      "type": "stat"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "bytes"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 3,
        "w": 3,
        "x": 3,
        "y": 1
      },
      "id": 60,
      "maxDataPoints": 100,
      "options": {
        "colorMode": "none",
        "graphMode": "none",
        "justifyMode": "auto",
        "orientation": "horizontal",
        "percentChangeColorMode": "standard",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showPercentChange": false,
        "textMode": "auto",
        "wideLayout": true
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "total_memory_RDB"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Total Memory",
      "type": "stat"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "bytes"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 3,
        "w": 3,
        "x": 6,
        "y": 1
      },
      "id": 178,
      "maxDataPoints": 100,
      "options": {
        "colorMode": "none",
        "graphMode": "none",
        "justifyMode": "auto",
        "orientation": "horizontal",
        "percentChangeColorMode": "standard",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showPercentChange": false,
        "textMode": "auto",
        "wideLayout": true
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "total_swap_RDB"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Total Swap",
      "type": "stat"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "bytes"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 3,
        "w": 3,
        "x": 9,
        "y": 1
      },
      "id": 179,
      "maxDataPoints": 100,
      "options": {
        "colorMode": "none",
        "graphMode": "none",
        "justifyMode": "auto",
        "orientation": "horizontal",
        "percentChangeColorMode": "standard",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showPercentChange": false,
        "textMode": "auto",
        "wideLayout": true
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "total_disk_size_RDB"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Total Disk",
      "type": "stat"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "palette-classic"
          },
          "custom": {
            "axisBorderShow": false,
            "axisCenteredZero": false,
            "axisColorMode": "text",
            "axisLabel": "",
            "axisPlacement": "auto",
            "barAlignment": 0,
            "barWidthFactor": 0.6,
            "drawStyle": "line",
            "fillOpacity": 20,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "insertNulls": false,
            "lineInterpolation": "smooth",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [],
          "thresholds": {
            "mode": "percentage",
            "steps": [
              {
                "color": "green",
                "value": 0
              }
            ]
          },
          "unit": "binBps"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 6,
        "w": 8,
        "x": 12,
        "y": 1
      },
      "id": 180,
      "options": {
        "legend": {
          "calcs": [
            "last"
          ],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "hideZeros": false,
          "mode": "multi",
          "sort": "none"
        }
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Down",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "logs",
          "select": [
            [
              {
                "params": [
                  "fm1-mac3_download_speed"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        },
        {
          "alias": "Up",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "B",
          "resultFormat": "logs",
          "select": [
            [
              {
                "params": [
                  "fm1-mac3_upload_speed"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Networking",
      "type": "timeseries"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 100,
          "min": 0,
          "thresholds": {
            "mode": "percentage",
            "steps": [
              {
                "color": "#73BF69",
                "value": 0
              },
              {
                "color": "rgba(237, 129, 40, 0.89)",
                "value": 70
              },
              {
                "color": "#d44a3a",
                "value": 85
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 2,
        "w": 4,
        "x": 20,
        "y": 1
      },
      "id": 183,
      "maxDataPoints": 100,
      "options": {
        "displayMode": "basic",
        "legend": {
          "calcs": [],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": false
        },
        "maxVizHeight": 300,
        "minVizHeight": 16,
        "minVizWidth": 8,
        "namePlacement": "auto",
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showUnfilled": true,
        "sizing": "auto",
        "valueMode": "color"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "B",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "swap_usage_RDB"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Swap Usage",
      "transparent": true,
      "type": "bargauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 100,
          "min": 0,
          "thresholds": {
            "mode": "percentage",
            "steps": [
              {
                "color": "#73BF69",
                "value": 0
              },
              {
                "color": "rgba(237, 129, 40, 0.89)",
                "value": 70
              },
              {
                "color": "#d44a3a",
                "value": 85
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 2,
        "w": 4,
        "x": 20,
        "y": 3
      },
      "id": 182,
      "maxDataPoints": 100,
      "options": {
        "displayMode": "basic",
        "legend": {
          "calcs": [],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": false
        },
        "maxVizHeight": 300,
        "minVizHeight": 16,
        "minVizWidth": 8,
        "namePlacement": "auto",
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showUnfilled": true,
        "sizing": "auto",
        "valueMode": "color"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "B",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "total_disk_usage_RDB"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        },
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": true,
          "limit": "1",
          "measurement": "memory",
          "orderByTime": "DESC",
          "policy": "default",
          "query": "SELECT mean(\"memused\") / 1073741824, mean(\"memtotal\") / 1073741824 FROM \"memory\" WHERE (\"host\" =~ /^$server$/) AND $timeFilter GROUP BY time($__interval) fill(null) ORDER BY time DESC LIMIT 1",
          "rawQuery": false,
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "memused"
                ],
                "type": "field"
              },
              {
                "params": [
                  "/ 1073741824"
                ],
                "type": "math"
              }
            ],
            [
              {
                "params": [
                  "memtotal"
                ],
                "type": "field"
              },
              {
                "params": [
                  "/ 1073741824"
                ],
                "type": "math"
              }
            ]
          ],
          "tags": [
            {
              "key": "host",
              "operator": "=~",
              "value": "/^$server$/"
            }
          ]
        }
      ],
      "title": "Disk Usage",
      "transparent": true,
      "type": "bargauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 1,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "dtdurations"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 3,
        "w": 9,
        "x": 0,
        "y": 4
      },
      "id": 16,
      "maxDataPoints": 100,
      "options": {
        "colorMode": "none",
        "graphMode": "none",
        "justifyMode": "auto",
        "orientation": "horizontal",
        "percentChangeColorMode": "standard",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showPercentChange": false,
        "textMode": "auto",
        "wideLayout": true
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "uptime_seconds_RDB"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Uptime",
      "transparent": true,
      "type": "stat"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "watt"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 3,
        "w": 3,
        "x": 9,
        "y": 4
      },
      "id": 184,
      "maxDataPoints": 100,
      "options": {
        "colorMode": "none",
        "graphMode": "none",
        "justifyMode": "auto",
        "orientation": "horizontal",
        "percentChangeColorMode": "standard",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showPercentChange": false,
        "textMode": "auto",
        "wideLayout": true
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "cpu_power_RDB"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "System Power",
      "type": "stat"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 100,
          "min": 0,
          "thresholds": {
            "mode": "percentage",
            "steps": [
              {
                "color": "#73BF69",
                "value": 0
              },
              {
                "color": "rgba(237, 129, 40, 0.89)",
                "value": 70
              },
              {
                "color": "#d44a3a",
                "value": 85
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 2,
        "w": 4,
        "x": 20,
        "y": 5
      },
      "id": 181,
      "maxDataPoints": 100,
      "options": {
        "displayMode": "basic",
        "legend": {
          "calcs": [],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": false
        },
        "maxVizHeight": 300,
        "minVizHeight": 16,
        "minVizWidth": 8,
        "namePlacement": "auto",
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showUnfilled": true,
        "sizing": "auto",
        "valueMode": "color"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "B",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "memory_usage_RDB"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        },
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": true,
          "limit": "1",
          "measurement": "memory",
          "orderByTime": "DESC",
          "policy": "default",
          "query": "SELECT mean(\"memused\") / 1073741824, mean(\"memtotal\") / 1073741824 FROM \"memory\" WHERE (\"host\" =~ /^$server$/) AND $timeFilter GROUP BY time($__interval) fill(null) ORDER BY time DESC LIMIT 1",
          "rawQuery": false,
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "memused"
                ],
                "type": "field"
              },
              {
                "params": [
                  "/ 1073741824"
                ],
                "type": "math"
              }
            ],
            [
              {
                "params": [
                  "memtotal"
                ],
                "type": "field"
              },
              {
                "params": [
                  "/ 1073741824"
                ],
                "type": "math"
              }
            ]
          ],
          "tags": [
            {
              "key": "host",
              "operator": "=~",
              "value": "/^$server$/"
            }
          ]
        }
      ],
      "title": "Memory Usage",
      "transparent": true,
      "type": "bargauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "palette-classic"
          },
          "custom": {
            "axisBorderShow": false,
            "axisCenteredZero": false,
            "axisColorMode": "text",
            "axisLabel": "",
            "axisPlacement": "auto",
            "barAlignment": 0,
            "barWidthFactor": 0.6,
            "drawStyle": "line",
            "fillOpacity": 20,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "insertNulls": false,
            "lineInterpolation": "smooth",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [],
          "thresholds": {
            "mode": "percentage",
            "steps": [
              {
                "color": "green",
                "value": 0
              }
            ]
          },
          "unit": "decmbytes"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 0,
        "y": 7
      },
      "id": 262,
      "options": {
        "legend": {
          "calcs": [
            "last"
          ],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "hideZeros": false,
          "mode": "multi",
          "sort": "none"
        }
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Mem usage",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "logs",
          "select": [
            [
              {
                "params": [
                  "memory_usage_RDB"
                ],
                "type": "field"
              },
              {
                "params": [
                  " / 100 * 3.71 * 1024"
                ],
                "type": "math"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Memory usage",
      "type": "timeseries"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "palette-classic"
          },
          "custom": {
            "axisBorderShow": false,
            "axisCenteredZero": false,
            "axisColorMode": "text",
            "axisLabel": "",
            "axisPlacement": "auto",
            "barAlignment": 0,
            "barWidthFactor": 0.6,
            "drawStyle": "line",
            "fillOpacity": 0,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "insertNulls": false,
            "lineInterpolation": "smooth",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "decimals": 2,
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "rotdegs"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 8,
        "y": 7
      },
      "id": 261,
      "options": {
        "legend": {
          "calcs": [
            "last"
          ],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "hideZeros": false,
          "mode": "single",
          "sort": "none"
        }
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Gyro x",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "gyro_x_filtered"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        },
        {
          "alias": "Gyro y",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "B",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "gyro_y_filtered"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        },
        {
          "alias": "Gyro z",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "C",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "gyro_z_filtered"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        },
        {
          "alias": "Gyro x",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": true,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "D",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "gyro_x"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        },
        {
          "alias": "Gyro y",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": true,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "E",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "gyro_y"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        },
        {
          "alias": "Gyro z",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": true,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "F",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "gyro_z"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Gyroscope",
      "type": "timeseries"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "palette-classic"
          },
          "custom": {
            "axisBorderShow": false,
            "axisCenteredZero": false,
            "axisColorMode": "text",
            "axisLabel": "",
            "axisPlacement": "auto",
            "barAlignment": 0,
            "barWidthFactor": 0.6,
            "drawStyle": "line",
            "fillOpacity": 0,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "insertNulls": false,
            "lineInterpolation": "smooth",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "decimals": 2,
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "accG"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 8,
        "w": 8,
        "x": 16,
        "y": 7
      },
      "id": 260,
      "options": {
        "legend": {
          "calcs": [
            "lastNotNull"
          ],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "hideZeros": false,
          "mode": "single",
          "sort": "none"
        }
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Accel x",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "accel_x"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        },
        {
          "alias": "Accel y",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "B",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "accel_y"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        },
        {
          "alias": "Accel z",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "C",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "accel_z"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Accelerometer",
      "type": "timeseries"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "fixedColor": "green",
            "mode": "fixed"
          },
          "custom": {
            "axisBorderShow": false,
            "axisCenteredZero": false,
            "axisColorMode": "text",
            "axisLabel": "",
            "axisPlacement": "auto",
            "barAlignment": 0,
            "barWidthFactor": 0.6,
            "drawStyle": "line",
            "fillOpacity": 0,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "insertNulls": false,
            "lineInterpolation": "smooth",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "decimals": 2,
          "mappings": [],
          "max": 180,
          "min": -180,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "degree"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 7,
        "w": 8,
        "x": 0,
        "y": 15
      },
      "id": 263,
      "options": {
        "legend": {
          "calcs": [
            "last"
          ],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "hideZeros": false,
          "mode": "single",
          "sort": "none"
        }
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Angle",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "angle_x"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Angle x-axis",
      "type": "timeseries"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "fixedColor": "yellow",
            "mode": "fixed"
          },
          "custom": {
            "axisBorderShow": false,
            "axisCenteredZero": false,
            "axisColorMode": "text",
            "axisLabel": "",
            "axisPlacement": "auto",
            "barAlignment": 0,
            "barWidthFactor": 0.6,
            "drawStyle": "line",
            "fillOpacity": 0,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "insertNulls": false,
            "lineInterpolation": "smooth",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "decimals": 2,
          "mappings": [],
          "max": 180,
          "min": -180,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "degree"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 7,
        "w": 8,
        "x": 8,
        "y": 15
      },
      "id": 264,
      "options": {
        "legend": {
          "calcs": [
            "last"
          ],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "hideZeros": false,
          "mode": "single",
          "sort": "none"
        }
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Angle",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "angle_y"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Angle y-axis",
      "type": "timeseries"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "fixedColor": "blue",
            "mode": "fixed"
          },
          "custom": {
            "axisBorderShow": false,
            "axisCenteredZero": false,
            "axisColorMode": "text",
            "axisLabel": "",
            "axisPlacement": "auto",
            "barAlignment": 0,
            "barWidthFactor": 0.6,
            "drawStyle": "line",
            "fillOpacity": 0,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "insertNulls": false,
            "lineInterpolation": "smooth",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "decimals": 2,
          "mappings": [],
          "max": 180,
          "min": -180,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "degree"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 7,
        "w": 8,
        "x": 16,
        "y": 15
      },
      "id": 265,
      "options": {
        "legend": {
          "calcs": [
            "last"
          ],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "hideZeros": false,
          "mode": "single",
          "sort": "none"
        }
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Angle",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "angle_z"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Angle z-axis",
      "type": "timeseries"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "fieldMinMax": false,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 1400000000,
          "min": 0,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "#73BF69",
                "value": 0
              },
              {
                "color": "rgba(237, 129, 40, 0.89)",
                "value": 800000000
              },
              {
                "color": "#d44a3a",
                "value": 1200000000
              }
            ]
          },
          "unit": "hertz"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 0,
        "y": 22
      },
      "id": 148,
      "maxDataPoints": 100,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "auto",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "B",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "per_core_freq_RDB2"
                ],
                "type": "field"
              },
              {
                "params": [
                  "*1000000"
                ],
                "type": "math"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "CPU core 3 frequency",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "fieldMinMax": false,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 1400000000,
          "min": 0,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "#73BF69",
                "value": 0
              },
              {
                "color": "rgba(237, 129, 40, 0.89)",
                "value": 800000000
              },
              {
                "color": "#d44a3a",
                "value": 1200000000
              }
            ]
          },
          "unit": "hertz"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 3,
        "y": 22
      },
      "id": 149,
      "maxDataPoints": 100,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "auto",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "B",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "per_core_freq_RDB3"
                ],
                "type": "field"
              },
              {
                "params": [
                  "*1000000"
                ],
                "type": "math"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "CPU core 4 frequency",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [],
          "max": 100,
          "thresholds": {
            "mode": "percentage",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 40
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 2,
        "w": 6,
        "x": 6,
        "y": 22
      },
      "id": 231,
      "options": {
        "displayMode": "gradient",
        "legend": {
          "calcs": [],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": false
        },
        "maxVizHeight": 300,
        "minVizHeight": 16,
        "minVizWidth": 8,
        "namePlacement": "auto",
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showUnfilled": true,
        "sizing": "auto",
        "valueMode": "color"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "per_core_usage_RDB0"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "CPU core 1 usage",
      "transparent": true,
      "type": "bargauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 1,
          "min": 0,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 0.5
              },
              {
                "color": "red",
                "value": 0.75
              }
            ]
          },
          "unit": "percentunit"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 8,
        "w": 6,
        "x": 12,
        "y": 22
      },
      "id": 2,
      "maxDataPoints": 100,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "B",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "cpu_usage_RDB"
                ],
                "type": "field"
              },
              {
                "params": [
                  " / 100"
                ],
                "type": "math"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Overall CPU usage",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 100,
          "min": 0,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "celsius"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 8,
        "w": 6,
        "x": 18,
        "y": 22
      },
      "id": 10,
      "maxDataPoints": 100,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "sys_temp_RDB"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "CPU temperature",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [],
          "max": 100,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 2,
        "w": 6,
        "x": 6,
        "y": 24
      },
      "id": 232,
      "options": {
        "displayMode": "gradient",
        "legend": {
          "calcs": [],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": false
        },
        "maxVizHeight": 300,
        "minVizHeight": 16,
        "minVizWidth": 8,
        "namePlacement": "auto",
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showUnfilled": true,
        "sizing": "auto",
        "valueMode": "color"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "per_core_usage_RDB1"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "CPU core 2 usage",
      "transparent": true,
      "type": "bargauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "fieldMinMax": false,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 1400000000,
          "min": 0,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "#73BF69",
                "value": 0
              },
              {
                "color": "rgba(237, 129, 40, 0.89)",
                "value": 800000000
              },
              {
                "color": "#d44a3a",
                "value": 1200000000
              }
            ]
          },
          "unit": "hertz"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 0,
        "y": 26
      },
      "id": 233,
      "maxDataPoints": 100,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "auto",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "B",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "per_core_freq_RDB0"
                ],
                "type": "field"
              },
              {
                "params": [
                  "*1000000"
                ],
                "type": "math"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "CPU core 1 frequency",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "fieldMinMax": false,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 1400000000,
          "min": 0,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "#73BF69",
                "value": 0
              },
              {
                "color": "rgba(237, 129, 40, 0.89)",
                "value": 800000000
              },
              {
                "color": "#d44a3a",
                "value": 1200000000
              }
            ]
          },
          "unit": "hertz"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 3,
        "y": 26
      },
      "id": 234,
      "maxDataPoints": 100,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "auto",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "B",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "per_core_freq_RDB1"
                ],
                "type": "field"
              },
              {
                "params": [
                  "*1000000"
                ],
                "type": "math"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "CPU core 2 frequency",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [],
          "max": 100,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 2,
        "w": 6,
        "x": 6,
        "y": 26
      },
      "id": 118,
      "options": {
        "displayMode": "gradient",
        "legend": {
          "calcs": [],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": false
        },
        "maxVizHeight": 300,
        "minVizHeight": 16,
        "minVizWidth": 8,
        "namePlacement": "auto",
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showUnfilled": true,
        "sizing": "auto",
        "valueMode": "color"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "per_core_usage_RDB2"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "CPU core 3 usage",
      "transparent": true,
      "type": "bargauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [],
          "max": 100,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 2,
        "w": 6,
        "x": 6,
        "y": 28
      },
      "id": 119,
      "options": {
        "displayMode": "gradient",
        "legend": {
          "calcs": [],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": false
        },
        "maxVizHeight": 300,
        "minVizHeight": 16,
        "minVizWidth": 8,
        "namePlacement": "auto",
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showUnfilled": true,
        "sizing": "auto",
        "valueMode": "color"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "per_core_usage_RDB3"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "CPU core 4 usage",
      "transparent": true,
      "type": "bargauge"
    },
    {
      "collapsed": true,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 30
      },
      "id": 254,
      "panels": [
        {
          "fieldConfig": {
            "defaults": {},
            "overrides": []
          },
          "gridPos": {
            "h": 19,
            "w": 24,
            "x": 0,
            "y": 31
          },
          "id": 255,
          "options": {
            "code": {
              "language": "plaintext",
              "showLineNumbers": true,
              "showMiniMap": true
            },
            "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Small Object Detection Interface</title>\n    <style>\n        .sod-widget-body {\n            font-family: Arial, sans-serif;\n            /* margin: 20px; */\n            /* background-color: #f5f5f5; */\n        }\n        \n        .sod-widget-button-container button {\n            background-color: #007bff;\n            color: white;\n            border: none;\n            padding: 12px 24px;\n            margin: 0 10px;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 16px;\n        }\n        \n        .sod-widget-button-container button:hover {\n            background-color: #0056b3;\n        }\n        \n        .sod-widget-button-container button:disabled {\n            background-color: #6c757d;\n            cursor: not-allowed;\n        }\n        \n        .sod-widget-status-bar {\n            background-color: #171b1f00;\n            padding: 10px;\n            border-radius: 4px;\n            margin-bottom: 20px;\n            text-align: center;\n            /* font-weight: bold; */\n        }\n        \n        /* .sod-widget-status-bar.running {\n            background-color: #d4edda;\n            color: #155724;\n        }\n        \n        .sod-widget-status-bar.error {\n            background-color: #f8d7da;\n            color: #721c24;\n        } */\n        \n        .sod-widget-image-display {\n            display: flex;\n            gap: 20px;\n            justify-content: center;\n            margin-bottom: 20px;\n        }\n        \n        .sod-widget-image-panel {\n            flex: 1;\n            /* max-width: 500px; */\n            text-align: center;\n        }\n        \n        .sod-widget-image-panel h3 {\n            margin-bottom: 10px;\n            /* color: #333; */\n        }\n        \n        .sod-widget-image-container {\n            border: 0.5px solid #2e3136;\n            border-radius: 3px;\n            /* padding: 10px; */\n            background-color: #181b1f;\n            min-height: 500px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        \n        .sod-widget-image-container img {\n            /* max-width: 100%; */\n            max-height: 500px;\n            object-fit: cover;\n            border-radius: 3px;\n            width: 925px;\n            height: 500px;\n        }\n        \n        .sod-widget-image-placeholder {\n            color: #666;\n            font-style: italic;\n        }\n        .sod-widget-control-panel {\n            display: flex;\n        }\n        \n        .sod-widget-button-container {\n            flex: 1;\n            /* margin-bottom: 20px; */\n            text-align: center;\n        }\n        \n        .sod-widget-progress-info {\n            flex: 1;\n            background-color: #171b1f00;\n            /* padding: 15px; */\n            border-radius: 3px;\n            /* margin-top: 20px; */\n        }\n        \n        .sod-widget-container {\n            /* max-width: 1200px; */\n            margin: 0 auto;\n            /* background-color: white; */\n            /* padding: 20px; */\n            border-radius: 3px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        \n        .sod-widget-progress-info h4 {\n            margin-top: 0;\n            /* color: #495057; */\n        }\n        \n        .sod-widget-loading {\n            display: inline-block;\n            width: 20px;\n            height: 20px;\n            border: 3px solid #f3f3f3;\n            border-top: 3px solid #3498db;\n            border-radius: 50%;\n            animation: spin 1s linear infinite;\n        }\n        \n        @keyframes spin {\n            0% { transform: rotate(0deg); }\n            100% { transform: rotate(360deg); }\n        }\n    </style>\n</head>\n<body class=\"sod-widget-body\">\n    <div class=\"sod-widget-container\">\n        \n        <div class=\"sod-widget-image-display\">\n            <div class=\"sod-widget-image-panel\">\n                <h3>Input image</h3>\n                <div class=\"sod-widget-image-container\">\n                    <div id=\"inputImageContainer\" class=\"sod-widget-image-placeholder\">\n                        Loading...\n                    </div>\n                </div>\n                <p id=\"inputImageInfo\"></p>\n            </div>\n            \n            <div class=\"sod-widget-image-panel\">\n                <h3>Output image</h3>\n                <div class=\"sod-widget-image-container\">\n                    <div id=\"outputImageContainer\" class=\"sod-widget-image-placeholder\">\n                        Loading...\n                    </div>\n                </div>\n                <p id=\"outputImageInfo\"></p>\n            </div>\n        </div>\n\n        <div class=\"sod-widget-control-panel\">\n            <div class=\"sod-widget-button-container\">\n                <button id=\"fetchBtn\" onclick=\"preloadImages()\">Fetch</button>\n                <button id=\"runBtn\" onclick=\"run_small_obj_detect()\">Run</button>\n                <button id=\"clearBtn\" onclick=\"clear_small_obj_detect()\">Clear</button>\n\n                <div id=\"statusBar\" class=\"sod-widget-status-bar\">Ready to start processing</div>\n                <p><strong>Processing Time:</strong> <span id=\"processingTime\">-</span></p>\n            </div>\n        \n            <!-- <div class=\"sod-widget-progress-info\">\n                <h4>Processing Information</h4>\n                <p><strong>Current Status:</strong> <span id=\"processStatus\">Idle</span></p>\n                <p><strong>Latest Output:</strong> <span id=\"latestOutput\">None</span></p>\n            </div> -->\n        </div>\n\n    </div>\n\n    <script>\n        let sodInputImageCache = {};\n        let sodOutputImageCache = {};\n        \n    (function() {\n        'use strict';\n        const FLASK_HOST = \"localhost\";\n        const FLASK_PORT = 5001;\n        \n        // let imageCache = {};\n        let sodInputImageCache = {};\n        let sodOutputImageCache = {};\n        \n        let isRunning = false;\n        let startTime = null;\n        let pollInterval = null;\n        \n        // // Preload all images when page loads\n        // window.addEventListener('load', function() {\n        //     preloadImages();\n        // });\n\n        function clearImages() {\n            document.getElementById('inputImageContainer').innerHTML = '<div class=\"sod-widget-image-placeholder\">Loading...</div>';\n            document.getElementById('outputImageContainer').innerHTML = '<div class=\"sod-widget-image-placeholder\">Loading...</div>';\n            document.getElementById('inputImageInfo').textContent = '';\n            document.getElementById('outputImageInfo').textContent = '';\n        }\n\n        function updateStatus(message, type = '') {\n            const statusBar = document.getElementById('statusBar');\n            statusBar.textContent = message;\n            statusBar.className = `sod-widget-status-bar ${type}`;\n        }\n\n        function updateButtons() {\n            const runBtn = document.getElementById('runBtn');\n            const clearBtn = document.getElementById('clearBtn');\n            \n            runBtn.disabled = isRunning;\n            runBtn.textContent = isRunning ? 'Processing...' : 'Run';\n        }\n\n        function updateProcessingTime() {\n            if (startTime) {\n                const elapsed = Math.floor((new Date() - startTime) / 1000);\n                const minutes = Math.floor(elapsed / 60);\n                const seconds = elapsed % 60;\n                document.getElementById('processingTime').textContent = \n                    `${minutes}:${seconds.toString().padStart(2, '0')}`;\n            }\n        }\n        \n        window.preloadImages = async function() {\n            try {\n                console.log('Starting enhanced image load...');\n                updateStatus('Loading image list...', 'running');\n                \n                const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/small_obj_detect/image_list`);\n                if (!response.ok) {\n                    throw new Error(`Failed to fetch image list: ${response.status}`);\n                }\n                \n                const data = await response.json();\n                console.log('Image list received:', data);\n                \n                const totalImages = data.input_images.length + data.output_images.length;\n                updateStatus(`Loading input images...`, 'running');\n                \n                // Enhanced image loading with retry mechanism\n                function loadImageWithRetry(src, filename, imageType, maxRetries = 3, timeout = 15000) {\n                    return new Promise((resolve, reject) => {\n                        let attempts = 0;\n                        \n                        function attemptLoad() {\n                            attempts++;\n                            console.log(`Attempting to load ${filename} (${imageType}) (attempt ${attempts}/${maxRetries})`);                            \n                            const img = new Image();\n                            let timeoutId;\n                            \n                            img.onload = () => {\n                                clearTimeout(timeoutId);\n                                console.log(` Successfully loaded: ${filename} (${imageType})`);\n                                \n                                // Validate that the image actually loaded with content\n                                if (img.naturalWidth > 0 && img.naturalHeight > 0) {\n                                    // Store in appropriate cache\n                                    if (imageType === 'input') {\n                                        sodInputImageCache[filename] = img;\n                                    } else {\n                                        sodOutputImageCache[filename] = img;\n                                    }\n                                    resolve({ success: true, filename, imageType, attempts });\n                                } else {\n                                    console.warn(` Image loaded but has no dimensions: ${filename} (${imageType})`);\n                                    if (attempts < maxRetries) {\n                                        setTimeout(attemptLoad, 1000 * attempts);\n                                    } else {\n                                        reject(new Error(`Image has no dimensions after ${maxRetries} attempts: ${filename} (${imageType})`));\n                                    }\n                                }\n                            };\n                            \n                            img.onerror = () => {\n                                clearTimeout(timeoutId);\n                                console.error(` Failed to load: ${filename} (${imageType}) (attempt ${attempts})`);\n                                \n                                if (attempts < maxRetries) {\n                                    setTimeout(attemptLoad, 1000 * attempts);\n                                } else {\n                                    reject(new Error(`Failed to load after ${maxRetries} attempts: ${filename} (${imageType})`));\n                                }\n                            };\n                            \n                            // Set timeout for this attempt\n                            timeoutId = setTimeout(() => {\n                                console.warn(` Timeout loading: ${filename} (${imageType}) (attempt ${attempts})`);                                img.src = ''; // Cancel the request\n                                \n                                if (attempts < maxRetries) {\n                                    setTimeout(attemptLoad, 1000 * attempts); // Progressive delay\n                                } else {\n                                    reject(new Error(`Timeout after ${maxRetries} attempts: ${filename} (${imageType})`));\n                                }\n                            }, timeout);\n                            \n                            img.src = src;\n                        }\n                        \n                        attemptLoad();\n                    });\n                }\n                \n                // Validate images exist on server before attempting to load\n                async function validateImageExists(filename, type) {\n                    try {\n                        const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/small_obj_detect/validate_image/${type}/${filename}`);\n                        if (response.ok) {\n                            const result = await response.json();\n                            return result.valid;\n                        }\n                        return false;\n                    } catch (error) {\n                        console.error(`Error validating image ${filename}:`, error);\n                        return false;\n                    }\n                }\n                \n                const loadPromises = [];\n                let validatedCount = 0;\n                \n                // Process input images\n                // Process input images\n                for (const filename of data.input_images) {\n                    const isValid = await validateImageExists(filename, 'input');\n                    if (isValid) {\n                        const src = `http://${FLASK_HOST}:${FLASK_PORT}/small_obj_detect/images/input/${filename}`;\n                        loadPromises.push(loadImageWithRetry(src, filename, 'input'));\n                        validatedCount++;\n                    } else {\n                        console.warn(`Skipping invalid input image: ${filename}`);\n                    }\n                }\n\n                // Process output images\n                for (const filename of data.output_images) {\n                    const isValid = await validateImageExists(filename, 'output');\n                    if (isValid) {\n                        const src = `http://${FLASK_HOST}:${FLASK_PORT}/small_obj_detect/images/output/${filename}`;\n                        loadPromises.push(loadImageWithRetry(src, filename, 'output'));\n                        validatedCount++;\n                    } else {\n                        console.warn(`Skipping invalid output image: ${filename}`);\n                    }\n                }\n                \n                console.log(`Validated ${validatedCount}/${totalImages} images, starting download...`);\n                updateStatus(`Loading ${validatedCount} validated images...`, 'running');\n                \n                // Track progress\n                let loadedCount = 0;\n                const progressPromises = loadPromises.map(promise => \n                    promise.then(result => {\n                        loadedCount++;\n                        const percentage = Math.round((loadedCount / validatedCount) * 100);\n                        updateStatus(`Loading images... ${loadedCount}/${validatedCount} (${percentage}%)`, 'running');\n                        return result;\n                    }).catch(error => {\n                        loadedCount++;\n                        const percentage = Math.round((loadedCount / validatedCount) * 100);\n                        updateStatus(`Loading images... ${loadedCount}/${validatedCount} (${percentage}%)`, 'running');\n                        throw error;\n                    })\n                );\n                \n                // Wait for all images with detailed results\n                const results = await Promise.allSettled(progressPromises);\n                \n                const successful = results.filter(r => r.status === 'fulfilled');\n                const failed = results.filter(r => r.status === 'rejected');\n                \n                console.log(`Load completed: ${successful.length} successful, ${failed.length} failed`);\n                \n                // Log detailed failure information\n                if (failed.length > 0) {\n                    console.group('Failed image loads:');\n                    failed.forEach((result, index) => {\n                        console.error(`${index + 1}. ${result.reason.message}`);\n                    });\n                    console.groupEnd();\n                }\n                \n                // Log successful loads with retry information\n                if (successful.length > 0) {\n                    console.group('Successful image loads:');\n                    successful.forEach(result => {\n                        const { filename, imageType, attempts } = result.value;\n                        if (attempts > 1) {\n                            console.log(`${filename} (${imageType}) (required ${attempts} attempts)`);\n                        }\n                    });\n                    console.groupEnd();\n                }\n                \n                const successRate = Math.round((successful.length / validatedCount) * 100);\n                \n                if (failed.length === 0) {\n                    // updateStatus(`All input images loaded successfully (${successful.length}/${validatedCount})`, 'ready');\n                    updateStatus(`All input images loaded successfully`, 'ready');\n                } else if (successful.length > 0) {\n                    // updateStatus(`Images loaded: ${successful.length}/${validatedCount} (${successRate}%) - ${failed.length} failed`, 'ready');\n                    updateStatus(`All input images loaded successfully`, 'ready');\n                } else {\n                    updateStatus('Failed to load input images - check console for details', 'error');\n                }\n                \n                // // Store validation results for later use\n                // window.imageValidationResults = {\n                //     total: validatedCount,\n                //     successful: successful.length,\n                //     failed: failed.length,\n                //     successRate: successRate\n                // };\n                \n                // console.log('Enhanced image preload completed - ready for display');\n\n                // Store validation results for later use\n                window.imageValidationResults = {\n                    total: validatedCount,\n                    successful: successful.length,\n                    failed: failed.length,\n                    successRate: successRate\n                };\n\n                console.log('Input image load completed - ready for display');\n                \n                // numToCheck = 300;\n                // // Validate first 100 input images\n                // const inputValidation = validateFirst100InputImages(numToCheck);\n\n                // // Update final status based on validation\n                // if (failed.length === 0 && inputValidation.success) {\n                //     // updateStatus(`All input images loaded and validated successfully (${successful.length}/${validatedCount})`, 'ready');\n                //     updateStatus(`All input images loaded and validated`, 'ready');\n                //     console.log(`All first ${numToCheck} input images are present in cache`);\n                // } else if (failed.length === 0 && !inputValidation.success) {\n                //     updateStatus(`Input images loaded: ${successful.length}/${validatedCount} - Missing ${inputValidation.missing}/${numToCheck} input images`, 'error');\n                //     console.warn(`Missing ${inputValidation.missing}/${numToCheck} input images`);\n                // } else if (successful.length > 0) {\n                //     updateStatus(`Input images loaded: ${successful.length}/${validatedCount} (${successRate}%) - ${failed.length} failed, ${inputValidation.missing}/${numToCheck} input missing`, 'error');\n                //     console.warn(`Missing ${inputValidation.missing}/${numToCheck} input images`);\n                // } else {\n                //     updateStatus('Failed to load input images - check console for details', 'error');\n                //     console.error('Failed to load input images - check console for details');\n                // }\n                                \n            } catch (error) {\n                console.error('Error in loading:', error);\n                updateStatus('Error loading input images - check network connection', 'error');\n            }\n        }\n\n        // function validateFirst100InputImages(numToCheck = 100) {\n        //     console.log(`Validating first ${numToCheck} input images in cache...`);\n            \n        //     const missingImages = [];\n        //     const presentImages = [];\n            \n        //     // Check images 1.webp through 100.webp\n        //     for (let i = 1; i <= numToCheck; i++) {\n        //         const filename = `${i}.webp`;\n        //         if (sodInputImageCache[filename]) {\n        //             presentImages.push(filename);\n        //         } else {\n        //             missingImages.push(filename);\n        //         }\n        //     }\n            \n        //     // Log results\n        //     console.log(`Input image validation results:`);\n        //     console.log(` Present: ${presentImages.length}/${numToCheck} images`);\n            \n        //     if (missingImages.length > 0) {\n        //         console.warn(` Missing: ${missingImages.length}/${numToCheck} images`);\n        //         console.group('Missing input images:');\n        //         missingImages.forEach(filename => {\n        //             console.warn(`- ${filename}`);\n        //         });\n        //         console.groupEnd();\n                \n        //         // Update status to show validation results\n        //         updateStatus(`Input images loaded with warnings: ${presentImages.length}/${numToCheck} input images found`, 'error');\n        //     } else {\n        //         console.log(` All first ${numToCheck} input images are present in cache`);\n        //         updateStatus(`All input images loaded successfully - First ${numToCheck} input images validated`, 'ready');\n        //     }\n            \n        //     // Store validation results\n        //     window.inputImageValidation = {\n        //         total: numToCheck,\n        //         present: presentImages.length,\n        //         missing: missingImages.length,\n        //         missingList: missingImages,\n        //         presentList: presentImages\n        //     };\n            \n        //     return {\n        //         success: missingImages.length === 0,\n        //         present: presentImages.length,\n        //         missing: missingImages.length,\n        //         missingList: missingImages\n        //     };\n        // }\n\n        window.run_small_obj_detect = function() {\n            if (isRunning) return;\n            \n            isRunning = true;\n            startTime = new Date();\n            \n            updateStatus('Starting small object detection...', 'running');\n            updateButtons();\n            \n            // Clear previous images\n            clearImages();\n            \n            try {\n                fetch(`http://${FLASK_HOST}:${FLASK_PORT}/send_message`, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({ message: \"run_small_obj_detect\" })\n                })\n                .then(response => response.json())\n                .then(data => {\n                    console.log(\"Command sent successfully:\", data);\n                    startProgressPolling();\n                })\n                .catch(error => {\n                    console.error(\"Error sending command:\", error);\n                    updateStatus('Error starting detection', 'error');\n                    isRunning = false;\n                    updateButtons();\n                });\n            } catch (error) {\n                console.error(\"Error:\", error);\n                updateStatus('Error starting detection', 'error');\n                isRunning = false;\n                updateButtons();\n            }\n        }\n        \n        window.clear_small_obj_detect = function() {\n            stopProgressPolling();\n            isRunning = false;\n            startTime = null;\n            \n            clearImages();\n            updateStatus('Cleared', 'ready');\n            updateButtons();\n            \n            // document.getElementById('processStatus').textContent = 'Idle';\n            // document.getElementById('latestOutput').textContent = 'None';\n            document.getElementById('processingTime').textContent = '-';\n            \n            // Send clear command to server\n            fetch(`http://${FLASK_HOST}:${FLASK_PORT}/send_message`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({ message: \"clear_small_obj_detect\" })\n            })\n            .catch(error => console.error(\"Error sending clear command:\", error));\n        }\n        \n        function startProgressPolling() {\n            if (pollInterval) clearInterval(pollInterval);\n            \n            pollInterval = setInterval(async () => {\n                try {\n                    const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/small_obj_detect/progress`);\n                    const data = await response.json();\n                    \n                    if (data.type) {\n                        handleProgressUpdate(data);\n                    }\n                } catch (error) {\n                    console.error('Error polling progress:', error);\n                }\n            }, 30);\n        }\n        \n        function stopProgressPolling() {\n            if (pollInterval) {\n                clearInterval(pollInterval);\n                pollInterval = null;\n            }\n        }\n        \n        function handleProgressUpdate(data) {\n            console.log('Progress update:', data);\n            \n            switch (data.type) {\n                case 'small_obj_detect_start':\n                    updateStatus('Detection started', 'running');\n                    // document.getElementById('processStatus').textContent = 'Running';\n                    break;\n                    \n                case 'small_obj_detect_progress':\n                    // Log what we're trying to display\n                    // console.log(`Attempting1111 input=${data.input_image}, output=${data.output_image}`);\n                    \n                    // Check if images exist in cache before displaying\n                    if (!sodInputImageCache[data.input_image]) {\n                        console.warn(`Input image ${data.input_image} not found in input cache`);\n                    }\n                    if (!sodOutputImageCache[data.output_image]) {\n                        console.warn(`Output image ${data.output_image} not found in output cache`);\n                    }\n                                        \n                    displayImagePair(data.input_image, data.output_image);\n                    // console.log(`Attempting2222 input=${data.input_image}, output=${data.output_image}`);\n                    // document.getElementById('latestOutput').textContent = data.output_image;\n\n                    updateProcessingTime();\n                    // console.log(`Attempting3333 input=${data.input_image}, output=${data.output_image}`);\n\n                    break;\n                    \n                case 'small_obj_detect_complete':\n                    updateStatus('Detection completed successfully', 'ready');\n                    // document.getElementById('processStatus').textContent = 'Completed';\n                    isRunning = false;\n                    updateButtons();\n                    stopProgressPolling();\n                    break;\n                    \n                case 'small_obj_detect_error':\n                    updateStatus(`Error: ${data.error}`, 'error');\n                    // document.getElementById('processStatus').textContent = 'Error';\n                    isRunning = false;\n                    updateButtons();\n                    stopProgressPolling();\n                    break;\n            }\n        }\n        \n        function displayImagePair(inputFilename, outputFilename) {\n            console.log(`Displaying images: input=${inputFilename}, output=${outputFilename}`);\n            const inputContainer = document.getElementById('inputImageContainer');\n            const outputContainer = document.getElementById('outputImageContainer');\n            const inputInfo = document.getElementById('inputImageInfo');\n            const outputInfo = document.getElementById('outputImageInfo');\n            \n            // Function to create and display image with fallback\n            function displayImage(filename, type, container, infoElement) {\n                let cachedImg;\n                \n                // Get image from appropriate cache\n                if (type === 'input') {\n                    cachedImg = sodInputImageCache[filename];\n                } else {\n                    cachedImg = sodOutputImageCache[filename];\n                }\n                \n                if (cachedImg && cachedImg.complete && cachedImg.naturalWidth > 0) {\n                    // Create a new image element to display\n                    const displayImg = document.createElement('img');\n                    displayImg.src = cachedImg.src;\n                    // displayImg.style.maxWidth = '100%';\n                    // displayImg.style.maxHeight = '400px';\n                    // displayImg.style.borderRadius = '4px';\n                    \n                    container.innerHTML = '';\n                    container.appendChild(displayImg);\n                    // infoElement.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)}: ${filename}`;\n                    infoElement.textContent = ``;\n                    \n                    // Add error handling for display\n                    displayImg.onerror = () => {\n                        console.error(`Failed to display ${type} image: ${filename}`);\n                        container.innerHTML = `<div class=\"sod-widget-image-placeholder\">Failed to display ${type} image</div>`;\n                    };\n                    \n                    return true;\n                } else {\n                    console.warn(`${type} image not available in cache: ${filename}`);\n                    container.innerHTML = `<div class=\"sod-widget-image-placeholder\">${type.charAt(0).toUpperCase() + type.slice(1)} image not available</div>`;\n                    return false;\n                }\n            }\n            \n            // Display both images\n            const inputDisplayed = displayImage(inputFilename, 'input', inputContainer, inputInfo);\n            const outputDisplayed = displayImage(outputFilename, 'output', outputContainer, outputInfo);\n            \n            // Log display status\n            if (inputDisplayed && outputDisplayed) {\n                console.log(`Successfully displayed both images: ${inputFilename} and ${outputFilename}`);\n            } else {\n                console.warn(`Partial display: input=${inputDisplayed}, output=${outputDisplayed}`);\n            }\n        }\n\n    })(); // End of IIFE\n    </script>\n</body>\n</html>",
            "mode": "html"
          },
          "pluginVersion": "12.1.0",
          "title": "",
          "transparent": true,
          "type": "text"
        }
      ],
      "title": "Visualisation",
      "type": "row"
    },
    {
      "collapsed": false,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 31
      },
      "id": 235,
      "panels": [],
      "title": "AI engine",
      "type": "row"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "fixedColor": "red",
            "mode": "thresholds"
          },
          "mappings": [],
          "max": 100,
          "min": 0,
          "thresholds": {
            "mode": "percentage",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 0,
        "y": 32
      },
      "id": 242,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "auto",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Core 1",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "logs",
          "select": [
            [
              {
                "params": [
                  "ai_core_0_freq"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 0 frequency",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "fixedColor": "red",
            "mode": "thresholds"
          },
          "mappings": [],
          "max": 100,
          "min": 0,
          "thresholds": {
            "mode": "percentage",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 3,
        "y": 32
      },
      "id": 256,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "auto",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Core 1",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "logs",
          "select": [
            [
              {
                "params": [
                  "ai_core_1_freq"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 2 frequency",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [],
          "max": 100,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 2,
        "w": 6,
        "x": 6,
        "y": 32
      },
      "id": 238,
      "options": {
        "displayMode": "gradient",
        "legend": {
          "calcs": [],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": false
        },
        "maxVizHeight": 300,
        "minVizHeight": 16,
        "minVizWidth": 8,
        "namePlacement": "auto",
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showUnfilled": true,
        "sizing": "auto",
        "valueMode": "color"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "ai_core_0_usage"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 1 usage",
      "transparent": true,
      "type": "bargauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 1,
          "min": 0,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 0.5
              },
              {
                "color": "red",
                "value": 0.75
              }
            ]
          },
          "unit": "percentunit"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 8,
        "w": 6,
        "x": 12,
        "y": 32
      },
      "id": 237,
      "maxDataPoints": 100,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "B",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "total_ai_usage"
                ],
                "type": "field"
              },
              {
                "params": [
                  " / 100"
                ],
                "type": "math"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Overall AI engine usage",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 100,
          "min": 0,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "celsius"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 18,
        "y": 32
      },
      "id": 236,
      "maxDataPoints": 100,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "ai_core_0_temp"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 1 temperature",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 100,
          "min": 0,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "celsius"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 21,
        "y": 32
      },
      "id": 251,
      "maxDataPoints": 100,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "ai_core_1_temp"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 2 temperature",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [],
          "max": 100,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 2,
        "w": 6,
        "x": 6,
        "y": 34
      },
      "id": 239,
      "options": {
        "displayMode": "gradient",
        "legend": {
          "calcs": [],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": false
        },
        "maxVizHeight": 300,
        "minVizHeight": 16,
        "minVizWidth": 8,
        "namePlacement": "auto",
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showUnfilled": true,
        "sizing": "auto",
        "valueMode": "color"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "ai_core_1_usage"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 2 usage",
      "transparent": true,
      "type": "bargauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "fixedColor": "red",
            "mode": "thresholds"
          },
          "mappings": [],
          "max": 100,
          "min": 0,
          "thresholds": {
            "mode": "percentage",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 0,
        "y": 36
      },
      "id": 257,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "auto",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Core 1",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "logs",
          "select": [
            [
              {
                "params": [
                  "ai_core_2_freq"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 3 frequency",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "fixedColor": "red",
            "mode": "thresholds"
          },
          "mappings": [],
          "max": 100,
          "min": 0,
          "thresholds": {
            "mode": "percentage",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 3,
        "y": 36
      },
      "id": 258,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "auto",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Core 1",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "logs",
          "select": [
            [
              {
                "params": [
                  "ai_core_3_freq"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 4 frequency",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [],
          "max": 100,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 2,
        "w": 6,
        "x": 6,
        "y": 36
      },
      "id": 240,
      "options": {
        "displayMode": "gradient",
        "legend": {
          "calcs": [],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": false
        },
        "maxVizHeight": 300,
        "minVizHeight": 16,
        "minVizWidth": 8,
        "namePlacement": "auto",
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showUnfilled": true,
        "sizing": "auto",
        "valueMode": "color"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "ai_core_2_usage"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 3 usage",
      "transparent": true,
      "type": "bargauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 100,
          "min": 0,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "celsius"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 18,
        "y": 36
      },
      "id": 252,
      "maxDataPoints": 100,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "ai_core_2_temp"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 3 temperature",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "description": "",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "decimals": 2,
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "max": 100,
          "min": 0,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "celsius"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 21,
        "y": 36
      },
      "id": 253,
      "maxDataPoints": 100,
      "options": {
        "minVizHeight": 75,
        "minVizWidth": 75,
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showThresholdLabels": false,
        "showThresholdMarkers": true,
        "sizing": "auto"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "ai_core_3_temp"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 4 temperature",
      "transparent": true,
      "type": "gauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [],
          "max": 100,
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "orange",
                "value": 50
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "percent"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 2,
        "w": 6,
        "x": 6,
        "y": 38
      },
      "id": 241,
      "options": {
        "displayMode": "gradient",
        "legend": {
          "calcs": [],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": false
        },
        "maxVizHeight": 300,
        "minVizHeight": 16,
        "minVizWidth": 8,
        "namePlacement": "auto",
        "orientation": "horizontal",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showUnfilled": true,
        "sizing": "auto",
        "valueMode": "color"
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "ai_core_3_usage"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 4 usage",
      "transparent": true,
      "type": "bargauge"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "palette-classic"
          },
          "custom": {
            "axisBorderShow": false,
            "axisCenteredZero": false,
            "axisColorMode": "text",
            "axisLabel": "",
            "axisPlacement": "auto",
            "barAlignment": 0,
            "barWidthFactor": 0.6,
            "drawStyle": "line",
            "fillOpacity": 0,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "insertNulls": false,
            "lineInterpolation": "linear",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "watt"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 7,
        "w": 5,
        "x": 0,
        "y": 40
      },
      "id": 247,
      "maxDataPoints": 100,
      "options": {
        "legend": {
          "calcs": [
            "last"
          ],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "hideZeros": false,
          "mode": "single",
          "sort": "none"
        }
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Power",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "ai_core_0_pwr"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 1 power",
      "type": "timeseries"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "fixedColor": "orange",
            "mode": "fixed"
          },
          "custom": {
            "axisBorderShow": false,
            "axisCenteredZero": false,
            "axisColorMode": "text",
            "axisLabel": "",
            "axisPlacement": "auto",
            "barAlignment": 0,
            "barWidthFactor": 0.6,
            "drawStyle": "line",
            "fillOpacity": 0,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "insertNulls": false,
            "lineInterpolation": "linear",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "watt"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 7,
        "w": 5,
        "x": 5,
        "y": 40
      },
      "id": 248,
      "maxDataPoints": 100,
      "options": {
        "legend": {
          "calcs": [
            "last"
          ],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "hideZeros": false,
          "mode": "single",
          "sort": "none"
        }
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Power",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "ai_core_1_pwr"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 2 power",
      "type": "timeseries"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "fixedColor": "yellow",
            "mode": "fixed"
          },
          "custom": {
            "axisBorderShow": false,
            "axisCenteredZero": false,
            "axisColorMode": "text",
            "axisLabel": "",
            "axisPlacement": "auto",
            "barAlignment": 0,
            "barWidthFactor": 0.6,
            "drawStyle": "line",
            "fillOpacity": 0,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "insertNulls": false,
            "lineInterpolation": "linear",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "watt"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 7,
        "w": 5,
        "x": 10,
        "y": 40
      },
      "id": 249,
      "maxDataPoints": 100,
      "options": {
        "legend": {
          "calcs": [
            "last"
          ],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "hideZeros": false,
          "mode": "single",
          "sort": "none"
        }
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Power",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "ai_core_2_pwr"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 3 power",
      "type": "timeseries"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "fixedColor": "red",
            "mode": "fixed"
          },
          "custom": {
            "axisBorderShow": false,
            "axisCenteredZero": false,
            "axisColorMode": "text",
            "axisLabel": "",
            "axisPlacement": "auto",
            "barAlignment": 0,
            "barWidthFactor": 0.6,
            "drawStyle": "line",
            "fillOpacity": 0,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "insertNulls": false,
            "lineInterpolation": "linear",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "watt"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 7,
        "w": 5,
        "x": 15,
        "y": 40
      },
      "id": 250,
      "maxDataPoints": 100,
      "options": {
        "legend": {
          "calcs": [
            "last"
          ],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "hideZeros": false,
          "mode": "single",
          "sort": "none"
        }
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Power",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "ai_core_3_pwr"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI core 4 power",
      "type": "timeseries"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "mappings": [
            {
              "options": {
                "match": "null",
                "result": {
                  "text": "N/A"
                }
              },
              "type": "special"
            }
          ],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": 0
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          },
          "unit": "watt"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 7,
        "w": 4,
        "x": 20,
        "y": 40
      },
      "id": 246,
      "maxDataPoints": 100,
      "options": {
        "colorMode": "none",
        "graphMode": "none",
        "justifyMode": "auto",
        "orientation": "horizontal",
        "percentChangeColorMode": "standard",
        "reduceOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "fields": "",
          "values": false
        },
        "showPercentChange": false,
        "textMode": "auto",
        "wideLayout": true
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "ai_total_pwr"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "AI engine total power",
      "type": "stat"
    },
    {
      "collapsed": true,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 47
      },
      "id": 270,
      "panels": [
        {
          "fieldConfig": {
            "defaults": {},
            "overrides": []
          },
          "gridPos": {
            "h": 18,
            "w": 24,
            "x": 0,
            "y": 48
          },
          "id": 271,
          "options": {
            "code": {
              "language": "plaintext",
              "showLineNumbers": false,
              "showMiniMap": false
            },
            "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>AI Smoke Interface</title>\n    <style>\n        .ai-ship-widget-body {\n            font-family: Arial, sans-serif;\n        }\n        \n        .ai-ship-widget-button-container button {\n            background-color: #007bff;\n            color: white;\n            border: none;\n            padding: 12px 24px;\n            margin: 0 10px;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 16px;\n        }\n        \n        .ai-ship-widget-button-container button:hover {\n            background-color: #0056b3;\n        }\n        \n        .ai-ship-widget-button-container button:disabled {\n            background-color: #6c757d;\n            cursor: not-allowed;\n        }\n        \n        .ai-ship-widget-status-bar {\n            background-color: #171b1f00;\n            padding: 10px;\n            border-radius: 4px;\n            margin-bottom: 20px;\n            text-align: center;\n        }\n        \n        .ai-ship-widget-image-display {\n            display: flex;\n            gap: 20px;\n            justify-content: center;\n            margin-bottom: 20px;\n        }\n        \n        .ai-ship-widget-image-panel {\n            flex: 1;\n            /* max-width: 500px; */\n            text-align: center;\n        }\n        \n        .ai-ship-widget-image-panel h3 {\n            margin-bottom: 10px;\n            /* color: #333; */\n        }\n        \n        .ai-ship-widget-image-container {\n            border: 0.5px solid #2e3136;\n            border-radius: 3px;\n            /* padding: 10px; */\n            background-color: #181b1f;\n            min-height: 600px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        \n        .ai-ship-widget-image-container img {\n            /* max-width: 100%; */\n            max-height: 800px;\n            object-fit: contain;\n            border-radius: 3px;\n            width: auto;\n            height: 600px;\n        }\n        \n        .ai-ship-widget-image-placeholder {\n            color: #666;\n            font-style: italic;\n        }\n        .ai-ship-widget-control-panel {\n            min-width: 450px;\n            display: flex;\n        }\n        \n        .ai-ship-widget-button-container {\n            flex: 1;\n            /* margin-bottom: 20px; */\n            text-align: center;\n            /* Center content vertically */\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n            gap: 15px; /* Space between elements */\n        }\n        \n        .ai-ship-widget-options-container {\n            flex: 1;\n            /* margin-bottom: 20px; */\n            text-align: center;\n        }\n        \n        .ai-ship-widget-progress-info {\n            flex: 1;\n            background-color: #171b1f00;\n            /* padding: 15px; */\n            border-radius: 3px;\n            /* margin-top: 20px; */\n        }\n        \n        .ai-ship-widget-container {\n            /* max-width: 1200px; */\n            margin: 0 auto;\n            /* background-color: white; */\n            /* padding: 20px; */\n            border-radius: 3px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        \n        .ai-ship-widget-progress-info h4 {\n            margin-top: 0;\n            /* color: #495057; */\n        }\n        \n        .ai-ship-widget-loading {\n            display: inline-block;\n            width: 20px;\n            height: 20px;\n            border: 3px solid #f3f3f3;\n            border-top: 3px solid #3498db;\n            border-radius: 50%;\n            animation: spin 1s linear infinite;\n        }\n        \n        @keyframes spin {\n            0% { transform: rotate(0deg); }\n            100% { transform: rotate(360deg); }\n        }\n\n        .ai-ship-widget-select {\n            font-size: 14px;\n            width: 70px;\n            height: 30px;\n            border-radius: 2px;\n            display: inline-block;\n        }\n    </style>\n</head>\n<body class=\"ai-ship-widget-body\">\n    <div class=\"ai-ship-widget-container\">\n        \n        <div class=\"ai-ship-widget-image-display\">\n            <div class=\"ai-ship-widget-image-panel\">\n                <h3>Input image</h3>\n                <div class=\"ai-ship-widget-image-container\">\n                    <div id=\"inputImageContainer_aiSmoke\" class=\"ai-ship-widget-image-placeholder\">\n                        Loading...\n                    </div>\n                </div>\n                <p id=\"inputImageInfo_aiSmoke\"></p>\n            </div>\n            \n            <div class=\"ai-ship-widget-image-panel\">\n                <h3>Output image</h3>\n                <div class=\"ai-ship-widget-image-container\">\n                    <div id=\"outputImageContainer_aiSmoke\" class=\"ai-ship-widget-image-placeholder\">\n                        Loading...\n                    </div>\n                </div>\n                <p id=\"outputImageInfo_aiSmoke\"></p>\n            </div>\n\n            <div class=\"ai-ship-widget-control-panel\">\n                <div class=\"ai-ship-widget-button-container\">\n                    <p><strong>Select number of running AI core:</strong>\n                        <select id=\"aiCoreDropdown\" class=\"ai-ship-widget-select\"\n                            onchange=\"select_num_ai_core_run()\">\n                        </select>\n                    </p>\n                    <div>\n                        <button id=\"fetchBtn_aiSmoke\" onclick=\"preload_ai_ship_images()\">Fetch</button>\n                        <button id=\"runBtn_aiSmoke\" onclick=\"run_ai_ship()\">Run</button>\n                        <button id=\"clearBtn_aiSmoke\" onclick=\"clear_ai_ship()\">Clear</button>\n                    </div>\n    \n                    <div id=\"statusBar_aiSmoke\" class=\"ai-ship-widget-status-bar\">Ready to start processing</div>\n                    <p style=\"margin-bottom: 0;\"><strong>Processed Images:</strong> <span id=\"processed_images_aiShip\">-</span></p>\n                    <p style=\"margin-top: 0;\"><strong>Processing Time:</strong> <span id=\"processingTime_aiShip\">-</span></p>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        let ai_ship_InputImageCache = {};\n        let ai_ship_OutputImageCache = {};\n        let ai_ship_displayInterval = null;\n\n    (function() {\n        'use strict';\n\n        let currentPairIndex = 0;\n        let aiCoreMonitorInterval = null;\n        let imageDisplayStarted = false;\n        const AI_USAGE_THRESHOLD = 5.0;  // Percentage above baseline to start display\n\n        const FLASK_HOST = \"localhost\";\n        const FLASK_PORT = 5001;\n\n        let isRunning_aiSmoke = false;\n        let startTime_aiShip = null;\n        let pollInterval_aiShip = null;\n        let processingTimeInterval = null;\n\n        let numAICoreRun = 4;\n        let imagePairs = [];\n\n        function startProcessingTimer() {\n            if (processingTimeInterval) clearInterval(processingTimeInterval);\n            processingTimeInterval = setInterval(() => {\n                update_processingTime_aiShip();\n            }, 1000); // Update every second\n        }\n\n        function stopProcessingTimer() {\n            if (processingTimeInterval) {\n                clearInterval(processingTimeInterval);\n                processingTimeInterval = null;\n            }\n        }\n\n        function startAICoreMonitoring() {\n            imageDisplayStarted = false;\n            updateStatus_aiSmoke('Waiting for AI cores to start...', 'running');\n            \n            if (aiCoreMonitorInterval) clearInterval(aiCoreMonitorInterval);\n            \n            aiCoreMonitorInterval = setInterval(async () => {\n                try {\n                    const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/ai_ship/ai_core_usage`);\n                    const data = await response.json();\n                    \n                    const usageIncrease = data.total_ai_usage - data.baseline;\n                    \n                    console.log(`AI Usage: ${data.total_ai_usage.toFixed(2)}%, Baseline: ${data.baseline.toFixed(2)}%, Increase: ${usageIncrease.toFixed(2)}%`);\n                    \n                    // If usage has increased significantly above baseline, start displaying images\n                    if (!imageDisplayStarted && usageIncrease > AI_USAGE_THRESHOLD) {\n                        console.log('AI cores are now active - starting image display');\n                        updateStatus_aiSmoke('AI cores active - processing images...', 'running');\n                        startLocalImageDisplay();\n                        imageDisplayStarted = true;\n                        stopAICoreMonitoring();\n                    }\n                } catch (error) {\n                    console.error('Error monitoring AI core usage:', error);\n                }\n            }, 200);  // Check every 200ms for quick response\n        }\n\n        function stopAICoreMonitoring() {\n            if (aiCoreMonitorInterval) {\n                clearInterval(aiCoreMonitorInterval);\n                aiCoreMonitorInterval = null;\n            }\n        }\n\n        // populate options for number of running AI core\n        function populate_options_num_ai_core_run() {\n            const dropdown = document.getElementById('aiCoreDropdown');\n            \n            // Only populate if dropdown exists and is empty\n            if (!dropdown) return;\n            if (dropdown.options.length > 0) return; // Already populated\n            \n            // Generate options 1 through 4\n            for (let i = 1; i <= 4; i++) {\n                const option = document.createElement('option');\n                option.value = i;\n                option.textContent = i;\n                \n                // Set option 4 as default\n                if (i === 4) {\n                    option.selected = true;\n                }\n                \n                dropdown.appendChild(option);\n            }\n        }\n\n        function ensureDropdownPopulated() {\n            const dropdown = document.getElementById('aiCoreDropdown');\n            if (dropdown && dropdown.options.length === 0) {\n                populate_options_num_ai_core_run();\n            }\n        }\n\n        populate_options_num_ai_core_run();\n\n        // Set up MutationObserver to watch for dropdown\n        const observer = new MutationObserver(() => {\n            ensureDropdownPopulated();\n        });\n\n        // Observe the body for changes\n        if (document.body) {\n            observer.observe(document.body, { childList: true, subtree: true });\n        }\n\n        // Also check periodically as backup\n        setInterval(ensureDropdownPopulated, 1000);\n\n        // ALSO EXPOSE THIS FUNCTION TO WINDOW\n        window.select_num_ai_core_run = function() {\n            const dropdown = document.getElementById('aiCoreDropdown');\n            numAICoreRun = parseInt(dropdown.value);\n            console.log('Number of AI cores selected:', numAICoreRun);\n        };\n\n        // function select_num_ai_core_run() {\n        //     const dropdown = document.getElementById('aiCoreDropdown');\n        //     numAICoreRun = parseInt(dropdown.value);\n        //     console.log('Number of AI cores selected:', numAICoreRun);\n        // }\n\n        function createShuffledPairs() {\n            const pairs = [];\n            // Create pairs from cached images\n            const inputKeys = Object.keys(ai_ship_InputImageCache);\n            const outputKeys = Object.keys(ai_ship_OutputImageCache);\n            \n            // Match input/output pairs (assuming they have corresponding numbers/names)\n            const minLength = Math.min(inputKeys.length, outputKeys.length);\n            for (let i = 0; i < minLength; i++) {\n                pairs.push({\n                    input: inputKeys[i],\n                    output: outputKeys[i]\n                });\n            }\n            \n            // Shuffle the pairs array\n            for (let i = pairs.length - 1; i > 0; i--) {\n                const j = Math.floor(Math.random() * (i + 1));\n                [pairs[i], pairs[j]] = [pairs[j], pairs[i]];\n            }\n            \n            return pairs;\n        }\n\n        function startLocalImageDisplay() {\n            // Create shuffled pairs\n            imagePairs = createShuffledPairs();\n            currentPairIndex = 0;\n            \n            // Display images every 0.5 seconds\n            ai_ship_displayInterval = setInterval(() => {\n                if (currentPairIndex < imagePairs.length) {\n                    const pair = imagePairs[currentPairIndex];\n                    displayImagePair(pair.input, pair.output);\n                    currentPairIndex++;\n                } else {\n                    // All pairs shown, restart from beginning\n                    currentPairIndex = 0;\n                }\n            }, 500);\n        }\n\n        function stopLocalImageDisplay() {\n            if (ai_ship_displayInterval) {\n                clearInterval(ai_ship_displayInterval);\n                ai_ship_displayInterval = null;\n            }\n        }\n\n        function clearImages_aiSmoke() {\n            document.getElementById('inputImageContainer_aiSmoke').innerHTML = '<div class=\"ai-ship-widget-image-placeholder\">Loading...</div>';\n            document.getElementById('outputImageContainer_aiSmoke').innerHTML = '<div class=\"ai-ship-widget-image-placeholder\">Loading...</div>';\n            document.getElementById('inputImageInfo_aiSmoke').textContent = '';\n            document.getElementById('outputImageInfo_aiSmoke').textContent = '';\n        }\n\n        function updateStatus_aiSmoke(message, type = '') {\n            const statusBar_aiSmoke = document.getElementById('statusBar_aiSmoke');\n            statusBar_aiSmoke.textContent = message;\n            statusBar_aiSmoke.className = `ai-ship-widget-status-bar ${type}`;\n        }\n\n        function updateButtons_aiSmoke() {\n            const runBtn_aiSmoke = document.getElementById('runBtn_aiSmoke');\n            const clearBtn_aiSmoke = document.getElementById('clearBtn_aiSmoke');\n            \n            runBtn_aiSmoke.disabled = isRunning_aiSmoke;\n            runBtn_aiSmoke.textContent = isRunning_aiSmoke ? 'Processing...' : 'Run';\n        }\n\n        function update_processingTime_aiShip() {\n            if (startTime_aiShip) {\n                const elapsed = Math.floor((new Date() - startTime_aiShip) / 1000);\n                const minutes = Math.floor(elapsed / 60);\n                const seconds = elapsed % 60;\n                document.getElementById('processingTime_aiShip').textContent = \n                    `${minutes}:${seconds.toString().padStart(2, '0')}`;\n            }\n        }\n        \n        window.preload_ai_ship_images = async function() {\n            try {\n                console.log('Starting enhanced image load...');\n                updateStatus_aiSmoke('Loading image list...', 'running');\n                \n                const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/ai_ship/image_list`);\n                if (!response.ok) {\n                    throw new Error(`Failed to fetch image list: ${response.status}`);\n                }\n                \n                const data = await response.json();\n                console.log('Image list received:', data);\n                \n                const totalImages = data.input_images.length + data.output_images.length;\n                updateStatus_aiSmoke(`Loading input images...`, 'running');\n                \n                // Enhanced image loading with retry mechanism\n                function loadImageWithRetry(src, filename, imageType, maxRetries = 3, timeout = 15000) {\n                    return new Promise((resolve, reject) => {\n                        let attempts = 0;\n                        \n                        function attemptLoad() {\n                            attempts++;\n                            console.log(`Attempting to load ${filename} (${imageType}) (attempt ${attempts}/${maxRetries})`);                            \n                            const img = new Image();\n                            let timeoutId;\n                            \n                            img.onload = () => {\n                                clearTimeout(timeoutId);\n                                console.log(` Successfully loaded: ${filename} (${imageType})`);\n                                \n                                // Validate that the image actually loaded with content\n                                if (img.naturalWidth > 0 && img.naturalHeight > 0) {\n                                    // Store in appropriate cache\n                                    if (imageType === 'input') {\n                                        ai_ship_InputImageCache[filename] = img;\n                                    } else {\n                                        ai_ship_OutputImageCache[filename] = img;\n                                    }\n                                    resolve({ success: true, filename, imageType, attempts });\n                                } else {\n                                    console.warn(` Image loaded but has no dimensions: ${filename} (${imageType})`);\n                                    if (attempts < maxRetries) {\n                                        setTimeout(attemptLoad, 1000 * attempts);\n                                    } else {\n                                        reject(new Error(`Image has no dimensions after ${maxRetries} attempts: ${filename} (${imageType})`));\n                                    }\n                                }\n                            };\n                            \n                            img.onerror = () => {\n                                clearTimeout(timeoutId);\n                                console.error(` Failed to load: ${filename} (${imageType}) (attempt ${attempts})`);\n                                \n                                if (attempts < maxRetries) {\n                                    setTimeout(attemptLoad, 1000 * attempts);\n                                } else {\n                                    reject(new Error(`Failed to load after ${maxRetries} attempts: ${filename} (${imageType})`));\n                                }\n                            };\n                            \n                            // Set timeout for this attempt\n                            timeoutId = setTimeout(() => {\n                                console.warn(` Timeout loading: ${filename} (${imageType}) (attempt ${attempts})`);                                img.src = ''; // Cancel the request\n                                \n                                if (attempts < maxRetries) {\n                                    setTimeout(attemptLoad, 1000 * attempts); // Progressive delay\n                                } else {\n                                    reject(new Error(`Timeout after ${maxRetries} attempts: ${filename} (${imageType})`));\n                                }\n                            }, timeout);\n                            \n                            img.src = src;\n                        }\n                        \n                        attemptLoad();\n                    });\n                }\n                \n                // Validate images exist on server before attempting to load\n                async function validateImageExists(filename, type) {\n                    try {\n                        const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/ai_ship/validate_image/${type}/${filename}`);\n                        if (response.ok) {\n                            const result = await response.json();\n                            return result.valid;\n                        }\n                        return false;\n                    } catch (error) {\n                        console.error(`Error validating image ${filename}:`, error);\n                        return false;\n                    }\n                }\n                \n                const loadPromises = [];\n                let validatedCount = 0;\n                \n                // Process input images\n                // Process input images\n                for (const filename of data.input_images) {\n                    const isValid = await validateImageExists(filename, 'input');\n                    if (isValid) {\n                        const src = `http://${FLASK_HOST}:${FLASK_PORT}/ai_ship/images/input/${filename}`;\n                        loadPromises.push(loadImageWithRetry(src, filename, 'input'));\n                        validatedCount++;\n                    } else {\n                        console.warn(`Skipping invalid input image: ${filename}`);\n                    }\n                }\n\n                // Process output images\n                for (const filename of data.output_images) {\n                    const isValid = await validateImageExists(filename, 'output');\n                    if (isValid) {\n                        const src = `http://${FLASK_HOST}:${FLASK_PORT}/ai_ship/images/output/${filename}`;\n                        loadPromises.push(loadImageWithRetry(src, filename, 'output'));\n                        validatedCount++;\n                    } else {\n                        console.warn(`Skipping invalid output image: ${filename}`);\n                    }\n                }\n                \n                console.log(`Validated ${validatedCount}/${totalImages} images, starting download...`);\n                updateStatus_aiSmoke(`Loading ${validatedCount} validated images...`, 'running');\n                \n                // Track progress\n                let loadedCount = 0;\n                const progressPromises = loadPromises.map(promise => \n                    promise.then(result => {\n                        loadedCount++;\n                        const percentage = Math.round((loadedCount / validatedCount) * 100);\n                        updateStatus_aiSmoke(`Loading images... ${loadedCount}/${validatedCount} (${percentage}%)`, 'running');\n                        return result;\n                    }).catch(error => {\n                        loadedCount++;\n                        const percentage = Math.round((loadedCount / validatedCount) * 100);\n                        updateStatus_aiSmoke(`Loading images... ${loadedCount}/${validatedCount} (${percentage}%)`, 'running');\n                        throw error;\n                    })\n                );\n                \n                // Wait for all images with detailed results\n                const results = await Promise.allSettled(progressPromises);\n                \n                const successful = results.filter(r => r.status === 'fulfilled');\n                const failed = results.filter(r => r.status === 'rejected');\n                \n                console.log(`Load completed: ${successful.length} successful, ${failed.length} failed`);\n                \n                // Log detailed failure information\n                if (failed.length > 0) {\n                    console.group('Failed image loads:');\n                    failed.forEach((result, index) => {\n                        console.error(`${index + 1}. ${result.reason.message}`);\n                    });\n                    console.groupEnd();\n                }\n                \n                // Log successful loads with retry information\n                if (successful.length > 0) {\n                    console.group('Successful image loads:');\n                    successful.forEach(result => {\n                        const { filename, imageType, attempts } = result.value;\n                        if (attempts > 1) {\n                            console.log(`${filename} (${imageType}) (required ${attempts} attempts)`);\n                        }\n                    });\n                    console.groupEnd();\n                }\n                \n                const successRate = Math.round((successful.length / validatedCount) * 100);\n                \n                if (failed.length === 0) {\n                    // updateStatus_aiSmoke(`All input images loaded successfully (${successful.length}/${validatedCount})`, 'ready');\n                    updateStatus_aiSmoke(`All input images loaded successfully`, 'ready');\n                } else if (successful.length > 0) {\n                    // updateStatus_aiSmoke(`Images loaded: ${successful.length}/${validatedCount} (${successRate}%) - ${failed.length} failed`, 'ready');\n                    updateStatus_aiSmoke(`All input images loaded successfully`, 'ready');\n                } else {\n                    updateStatus_aiSmoke('Failed to load input images - check console for details', 'error');\n                }\n\n                // Store validation results for later use\n                window.imageValidationResults = {\n                    total: validatedCount,\n                    successful: successful.length,\n                    failed: failed.length,\n                    successRate: successRate\n                };\n\n                console.log('Input image load completed - ready for display');\n                                \n            } catch (error) {\n                console.error('Error in loading:', error);\n                updateStatus_aiSmoke('Error loading input images - check network connection', 'error');\n            }\n        }\n\n        window.run_ai_ship = function() {\n            if (isRunning_aiSmoke) return;\n            \n            isRunning_aiSmoke = true;\n            startTime_aiShip = new Date();\n            startProcessingTimer();\n            \n            updateStatus_aiSmoke('Starting ai smoke...', 'running');\n            updateButtons_aiSmoke();\n            \n            // Clear previous images\n            clearImages_aiSmoke();\n            \n            try {\n                fetch(`http://${FLASK_HOST}:${FLASK_PORT}/send_message`, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({ message: `run_ai_ship:${numAICoreRun}` })\n                })\n                .then(response => response.json())\n                .then(data => {\n                    console.log(\"Command sent successfully:\", data);\n                    // startProgressPolling();\n                    startAICoreMonitoring();  // wait for AI cores\n                    startCompletionPolling();\n                })\n                .catch(error => {\n                    console.error(\"Error sending command:\", error);\n                    updateStatus_aiSmoke('Error starting detection', 'error');\n                    isRunning_aiSmoke = false;\n                    updateButtons_aiSmoke();\n                });\n            } catch (error) {\n                console.error(\"Error:\", error);\n                updateStatus_aiSmoke('Error starting detection', 'error');\n                isRunning_aiSmoke = false;\n                updateButtons_aiSmoke();\n            }\n        }\n        \n        window.clear_ai_ship = function() {\n            stopLocalImageDisplay();\n            stopAICoreMonitoring();\n            stopProgressPolling();\n            isRunning_aiSmoke = false;\n            startTime_aiShip = null;\n            \n            clearImages_aiSmoke();\n            stopProcessingTimer();\n            updateStatus_aiSmoke('Cleared', 'ready');\n            updateButtons_aiSmoke();\n            \n            // document.getElementById('processStatus').textContent = 'Idle';\n            // document.getElementById('latestOutput').textContent = 'None';\n            document.getElementById('processed_images_aiShip').textContent = '-';\n            document.getElementById('processingTime_aiShip').textContent = '-';\n            \n            // Send clear command to server\n            fetch(`http://${FLASK_HOST}:${FLASK_PORT}/send_message`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({ message: \"clear_ai_ship\" })\n            })\n            .catch(error => console.error(\"Error sending clear command:\", error));\n        }\n        \n        // function startProgressPolling() {\n        //     if (pollInterval_aiShip) clearInterval(pollInterval_aiShip);\n            \n        //     pollInterval_aiShip = setInterval(async () => {\n        //         try {\n        //             const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/ai_ship/progress`);\n        //             const data = await response.json();\n                    \n        //             if (data.type) {\n        //                 handleProgressUpdate(data);\n        //             }\n        //         } catch (error) {\n        //             console.error('Error polling progress:', error);\n        //         }\n        //     }, 30);\n        // }\n\n        function startCompletionPolling() {\n            if (pollInterval_aiShip) clearInterval(pollInterval_aiShip);\n            \n            pollInterval_aiShip = setInterval(async () => {\n                try {\n                    const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/ai_ship/progress`);\n                    const data = await response.json();\n\n                    console.log(`AI ship progress: ${data.type}`);\n                    \n                    if (data.type === 'ai_ship_complete') {\n                        console.log(\"AI ship application completed\")\n                        handleCompletion();\n                        document.getElementById('processed_images_aiShip').textContent = '2,199';\n                    } else if (data.type === 'ai_ship_error') {\n                        handleError(data.error);\n                    }\n                } catch (error) {\n                    console.error('Error polling completion:', error);\n                }\n            }, 500); // Poll every 500ms\n        }\n        \n        function stopProgressPolling() {\n            if (pollInterval_aiShip) {\n                clearInterval(pollInterval_aiShip);\n                pollInterval_aiShip = null;\n            }\n        }\n\n        function handleCompletion() {\n            stopLocalImageDisplay();\n            stopProcessingTimer();\n            stopAICoreMonitoring();\n            updateStatus_aiSmoke('Detection completed successfully', 'ready');\n            isRunning_aiSmoke = false;\n            updateButtons_aiSmoke();\n            stopProgressPolling();\n        }\n\n        function handleError(errorMsg) {\n            stopLocalImageDisplay();\n            stopProcessingTimer();\n            stopAICoreMonitoring();\n            updateStatus_aiSmoke(`Error: ${errorMsg}`, 'error');\n            isRunning_aiSmoke = false;\n            updateButtons_aiSmoke();\n            stopProgressPolling();\n        }\n        \n        function displayImagePair(inputFilename, outputFilename) {\n            // console.log(`Displaying images: input=${inputFilename}, output=${outputFilename}`);\n            const inputContainer = document.getElementById('inputImageContainer_aiSmoke');\n            const outputContainer = document.getElementById('outputImageContainer_aiSmoke');\n            const inputInfo = document.getElementById('inputImageInfo_aiSmoke');\n            const outputInfo = document.getElementById('outputImageInfo_aiSmoke');\n            \n            // Function to create and display image with fallback\n            function displayImage(filename, type, container, infoElement) {\n                let cachedImg;\n                \n                // Get image from appropriate cache\n                if (type === 'input') {\n                    cachedImg = ai_ship_InputImageCache[filename];\n                } else {\n                    cachedImg = ai_ship_OutputImageCache[filename];\n                }\n                \n                if (cachedImg && cachedImg.complete && cachedImg.naturalWidth > 0) {\n                    // Create a new image element to display\n                    const displayImg = document.createElement('img');\n                    displayImg.src = cachedImg.src;\n                    \n                    container.innerHTML = '';\n                    container.appendChild(displayImg);\n                    // infoElement.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)}: ${filename}`;\n                    infoElement.textContent = ``;\n                    \n                    // Add error handling for display\n                    displayImg.onerror = () => {\n                        console.error(`Failed to display ${type} image: ${filename}`);\n                        container.innerHTML = `<div class=\"ai-ship-widget-image-placeholder\">Failed to display ${type} image</div>`;\n                    };\n                    \n                    return true;\n                } else {\n                    console.warn(`${type} image not available in cache: ${filename}`);\n                    container.innerHTML = `<div class=\"ai-ship-widget-image-placeholder\">${type.charAt(0).toUpperCase() + type.slice(1)} image not available</div>`;\n                    return false;\n                }\n            }\n            \n            // Display both images\n            const inputDisplayed = displayImage(inputFilename, 'input', inputContainer, inputInfo);\n            const outputDisplayed = displayImage(outputFilename, 'output', outputContainer, outputInfo);\n            \n            // Log display status\n            if (inputDisplayed && outputDisplayed) {\n                // console.log(`Successfully displayed both images: ${inputFilename} and ${outputFilename}`);\n            } else {\n                console.warn(`Partial display: input=${inputDisplayed}, output=${outputDisplayed}`);\n            }\n        }\n    \n    })(); // End of IIFE\n    </script>\n</body>\n</html>",
            "mode": "html"
          },
          "pluginVersion": "12.1.0",
          "title": "",
          "transparent": true,
          "type": "text"
        }
      ],
      "title": "AI Ship",
      "type": "row"
    },
    {
      "collapsed": true,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 48
      },
      "id": 269,
      "panels": [
        {
          "fieldConfig": {
            "defaults": {},
            "overrides": []
          },
          "gridPos": {
            "h": 18,
            "w": 24,
            "x": 0,
            "y": 49
          },
          "id": 268,
          "options": {
            "code": {
              "language": "plaintext",
              "showLineNumbers": true,
              "showMiniMap": true
            },
            "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>AI Smoke Interface</title>\n    <style>\n        .ai-smoke-widget-body {\n            font-family: Arial, sans-serif;\n        }\n        \n        .ai-smoke-widget-button-container button {\n            background-color: #007bff;\n            color: white;\n            border: none;\n            padding: 12px 24px;\n            margin: 0 10px;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 16px;\n        }\n        \n        .ai-smoke-widget-button-container button:hover {\n            background-color: #0056b3;\n        }\n        \n        .ai-smoke-widget-button-container button:disabled {\n            background-color: #6c757d;\n            cursor: not-allowed;\n        }\n        \n        .ai-smoke-widget-status-bar {\n            background-color: #171b1f00;\n            padding: 10px;\n            border-radius: 4px;\n            margin-bottom: 20px;\n            text-align: center;\n        }\n        \n        .ai-smoke-widget-image-display {\n            display: flex;\n            gap: 20px;\n            justify-content: center;\n            margin-bottom: 20px;\n        }\n        \n        .ai-smoke-widget-image-panel {\n            flex: 1;\n            /* max-width: 500px; */\n            text-align: center;\n        }\n        \n        .ai-smoke-widget-image-panel h3 {\n            margin-bottom: 10px;\n            /* color: #333; */\n        }\n        \n        .ai-smoke-widget-image-container {\n            border: 0.5px solid #2e3136;\n            border-radius: 3px;\n            /* padding: 10px; */\n            background-color: #181b1f;\n            min-height: 600px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        \n        .ai-smoke-widget-image-container img {\n            /* max-width: 100%; */\n            max-height: 800px;\n            object-fit: contain;\n            border-radius: 3px;\n            width: auto;\n            height: 600px;\n        }\n        \n        .ai-smoke-widget-image-placeholder {\n            color: #666;\n            font-style: italic;\n        }\n        .ai-smoke-widget-control-panel {\n            min-width: 450px;\n            display: flex;\n        }\n        \n        .ai-smoke-widget-button-container {\n            flex: 1;\n            /* margin-bottom: 20px; */\n            text-align: center;\n            /* Center content vertically */\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n            gap: 15px; /* Space between elements */\n        }\n        \n        .ai-smoke-widget-options-container {\n            flex: 1;\n            /* margin-bottom: 20px; */\n            text-align: center;\n        }\n        \n        .ai-smoke-widget-progress-info {\n            flex: 1;\n            background-color: #171b1f00;\n            /* padding: 15px; */\n            border-radius: 3px;\n            /* margin-top: 20px; */\n        }\n        \n        .ai-smoke-widget-container {\n            /* max-width: 1200px; */\n            margin: 0 auto;\n            /* background-color: white; */\n            /* padding: 20px; */\n            border-radius: 3px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n        }\n        \n        .ai-smoke-widget-progress-info h4 {\n            margin-top: 0;\n            /* color: #495057; */\n        }\n        \n        .ai-smoke-widget-loading {\n            display: inline-block;\n            width: 20px;\n            height: 20px;\n            border: 3px solid #f3f3f3;\n            border-top: 3px solid #3498db;\n            border-radius: 50%;\n            animation: spin 1s linear infinite;\n        }\n        \n        @keyframes spin {\n            0% { transform: rotate(0deg); }\n            100% { transform: rotate(360deg); }\n        }\n\n        .ai-smoke-widget-select {\n            font-size: 14px;\n            width: 70px;\n            height: 30px;\n            border-radius: 2px;\n            display: inline-block;\n        }\n    </style>\n</head>\n<body class=\"ai-smoke-widget-body\">\n    <div class=\"ai-smoke-widget-container\">\n        \n        <div class=\"ai-smoke-widget-image-display\">\n            <div class=\"ai-smoke-widget-image-panel\">\n                <h3>Input image</h3>\n                <div class=\"ai-smoke-widget-image-container\">\n                    <div id=\"inputImageContainer_aiSmoke\" class=\"ai-smoke-widget-image-placeholder\">\n                        Loading...\n                    </div>\n                </div>\n                <p id=\"inputImageInfo_aiSmoke\"></p>\n            </div>\n            \n            <div class=\"ai-smoke-widget-image-panel\">\n                <h3>Output image</h3>\n                <div class=\"ai-smoke-widget-image-container\">\n                    <div id=\"outputImageContainer_aiSmoke\" class=\"ai-smoke-widget-image-placeholder\">\n                        Loading...\n                    </div>\n                </div>\n                <p id=\"outputImageInfo_aiSmoke\"></p>\n            </div>\n\n            <div class=\"ai-smoke-widget-control-panel\">\n                <div class=\"ai-smoke-widget-button-container\">\n                    <p><strong>Select number of running AI core:</strong>\n                        <select id=\"aiCoreDropdown\" class=\"ai-smoke-widget-select\"\n                            onchange=\"select_num_ai_core_run()\">\n                        </select>\n                    </p>\n                    <div>\n                        <button id=\"fetchBtn_aiSmoke\" onclick=\"preload_ai_smoke_images()\">Fetch</button>\n                        <button id=\"runBtn_aiSmoke\" onclick=\"run_ai_smoke()\">Run</button>\n                        <button id=\"clearBtn_aiSmoke\" onclick=\"clear_ai_smoke()\">Clear</button>\n                    </div>\n    \n                    <div id=\"statusBar_aiSmoke\" class=\"ai-smoke-widget-status-bar\">Ready to start processing</div>\n                    <p style=\"margin-bottom: 0;\"><strong>Processed Images:</strong> <span id=\"processed_images_aiSmoke\">-</span></p>\n                    <p style=\"margin-top: 0;\"><strong>Processing Time:</strong> <span id=\"processingTime_aiSmoke\">-</span></p>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        let ai_smoke_InputImageCache = {};\n        let ai_smoke_OutputImageCache = {};\n        let numAICoreRun = 4;\n        let displayInterval = null;\n        let imagePairs = [];\n\n\n    (function() {\n        'use strict';\n\n        let currentPairIndex = 0;\n        let aiCoreMonitorInterval = null;\n        let imageDisplayStarted = false;\n        const AI_USAGE_THRESHOLD = 5.0;  // Percentage above baseline to start display\n\n        let processingTimeInterval = null;\n\n        function startProcessingTimer() {\n            if (processingTimeInterval) clearInterval(processingTimeInterval);\n            processingTimeInterval = setInterval(() => {\n                update_processingTime_aiSmoke();\n            }, 1000); // Update every second\n        }\n\n        function stopProcessingTimer() {\n            if (processingTimeInterval) {\n                clearInterval(processingTimeInterval);\n                processingTimeInterval = null;\n            }\n        }\n\n        // // populate options for number of running AI core\n        // populate_options_num_ai_core_run();\n\n        // function populate_options_num_ai_core_run() {\n        //     const dropdown = document.getElementById('aiCoreDropdown');\n            \n        //     // Generate options 1 through 4\n        //     for (let i = 1; i <= 4; i++) {\n        //         const option = document.createElement('option');\n        //         option.value = i;\n        //         option.textContent = i;\n                \n        //         // Set option 4 as default\n        //         if (i === 4) {\n        //             option.selected = true;\n        //         }\n                \n        //         dropdown.appendChild(option);\n        //     }\n        // }\n\n        function startAICoreMonitoring() {\n            imageDisplayStarted = false;\n            updateStatus_aiSmoke('Waiting for AI cores to start...', 'running');\n            \n            if (aiCoreMonitorInterval) clearInterval(aiCoreMonitorInterval);\n            \n            aiCoreMonitorInterval = setInterval(async () => {\n                try {\n                    const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/ai_smoke/ai_core_usage`);\n                    const data = await response.json();\n                    \n                    const usageIncrease = data.total_ai_usage - data.baseline;\n                    \n                    console.log(`AI Usage: ${data.total_ai_usage.toFixed(2)}%, Baseline: ${data.baseline.toFixed(2)}%, Increase: ${usageIncrease.toFixed(2)}%`);\n                    \n                    // If usage has increased significantly above baseline, start displaying images\n                    if (!imageDisplayStarted && usageIncrease > AI_USAGE_THRESHOLD) {\n                        console.log('AI cores are now active - starting image display');\n                        updateStatus_aiSmoke('AI cores active - processing images...', 'running');\n                        startLocalImageDisplay();\n                        imageDisplayStarted = true;\n                        stopAICoreMonitoring();\n                    }\n                } catch (error) {\n                    console.error('Error monitoring AI core usage:', error);\n                }\n            }, 200);  // Check every 200ms for quick response\n        }\n\n        function stopAICoreMonitoring() {\n            if (aiCoreMonitorInterval) {\n                clearInterval(aiCoreMonitorInterval);\n                aiCoreMonitorInterval = null;\n            }\n        }\n\n        // populate options for number of running AI core\n        function populate_options_num_ai_core_run() {\n            const dropdown = document.getElementById('aiCoreDropdown');\n            \n            // Only populate if dropdown exists and is empty\n            if (!dropdown) return;\n            if (dropdown.options.length > 0) return; // Already populated\n            \n            // Generate options 1 through 4\n            for (let i = 1; i <= 4; i++) {\n                const option = document.createElement('option');\n                option.value = i;\n                option.textContent = i;\n                \n                // Set option 4 as default\n                if (i === 4) {\n                    option.selected = true;\n                }\n                \n                dropdown.appendChild(option);\n            }\n        }\n\n        function ensureDropdownPopulated() {\n            const dropdown = document.getElementById('aiCoreDropdown');\n            if (dropdown && dropdown.options.length === 0) {\n                populate_options_num_ai_core_run();\n            }\n        }\n\n        populate_options_num_ai_core_run();\n\n        // Set up MutationObserver to watch for dropdown\n        const observer = new MutationObserver(() => {\n            ensureDropdownPopulated();\n        });\n\n        // Observe the body for changes\n        if (document.body) {\n            observer.observe(document.body, { childList: true, subtree: true });\n        }\n\n        // Also check periodically as backup\n        setInterval(ensureDropdownPopulated, 1000);\n\n        // ALSO EXPOSE THIS FUNCTION TO WINDOW\n        window.select_num_ai_core_run = function() {\n            const dropdown = document.getElementById('aiCoreDropdown');\n            numAICoreRun = parseInt(dropdown.value);\n            console.log('Number of AI cores selected:', numAICoreRun);\n        };\n\n        // function select_num_ai_core_run() {\n        //     const dropdown = document.getElementById('aiCoreDropdown');\n        //     numAICoreRun = parseInt(dropdown.value);\n        //     console.log('Number of AI cores selected:', numAICoreRun);\n        // }\n\n        function createShuffledPairs() {\n            const pairs = [];\n            // Create pairs from cached images\n            const inputKeys = Object.keys(ai_smoke_InputImageCache);\n            const outputKeys = Object.keys(ai_smoke_OutputImageCache);\n            \n            // Match input/output pairs (assuming they have corresponding numbers/names)\n            const minLength = Math.min(inputKeys.length, outputKeys.length);\n            for (let i = 0; i < minLength; i++) {\n                pairs.push({\n                    input: inputKeys[i],\n                    output: outputKeys[i]\n                });\n            }\n            \n            // Shuffle the pairs array\n            for (let i = pairs.length - 1; i > 0; i--) {\n                const j = Math.floor(Math.random() * (i + 1));\n                [pairs[i], pairs[j]] = [pairs[j], pairs[i]];\n            }\n            \n            return pairs;\n        }\n\n        function startLocalImageDisplay() {\n            // Create shuffled pairs\n            imagePairs = createShuffledPairs();\n            currentPairIndex = 0;\n            \n            // Display images every 0.5 seconds\n            displayInterval = setInterval(() => {\n                if (currentPairIndex < imagePairs.length) {\n                    const pair = imagePairs[currentPairIndex];\n                    displayImagePair(pair.input, pair.output);\n                    currentPairIndex++;\n                } else {\n                    // All pairs shown, restart from beginning\n                    currentPairIndex = 0;\n                }\n            }, 500);\n        }\n\n        function stopLocalImageDisplay() {\n            if (displayInterval) {\n                clearInterval(displayInterval);\n                displayInterval = null;\n            }\n        }\n\n\n\n\n        const FLASK_HOST = \"localhost\";\n        const FLASK_PORT = 5001;\n        \n        let isRunning_aiSmoke = false;\n        let startTime_aiSmoke = null;\n        let pollInterval_aiSmoke = null;\n        \n        // // Preload all images when page loads\n        // window.addEventListener('load', function() {\n        //     preload_ai_smoke_images();\n        // });\n\n        function clearImages_aiSmoke() {\n            document.getElementById('inputImageContainer_aiSmoke').innerHTML = '<div class=\"ai-smoke-widget-image-placeholder\">Loading...</div>';\n            document.getElementById('outputImageContainer_aiSmoke').innerHTML = '<div class=\"ai-smoke-widget-image-placeholder\">Loading...</div>';\n            document.getElementById('inputImageInfo_aiSmoke').textContent = '';\n            document.getElementById('outputImageInfo_aiSmoke').textContent = '';\n        }\n\n        function updateStatus_aiSmoke(message, type = '') {\n            const statusBar_aiSmoke = document.getElementById('statusBar_aiSmoke');\n            statusBar_aiSmoke.textContent = message;\n            statusBar_aiSmoke.className = `ai-smoke-widget-status-bar ${type}`;\n        }\n\n        function updateButtons_aiSmoke() {\n            const runBtn_aiSmoke = document.getElementById('runBtn_aiSmoke');\n            const clearBtn_aiSmoke = document.getElementById('clearBtn_aiSmoke');\n            \n            runBtn_aiSmoke.disabled = isRunning_aiSmoke;\n            runBtn_aiSmoke.textContent = isRunning_aiSmoke ? 'Processing...' : 'Run';\n        }\n\n        function update_processingTime_aiSmoke() {\n            if (startTime_aiSmoke) {\n                const elapsed = Math.floor((new Date() - startTime_aiSmoke) / 1000);\n                const minutes = Math.floor(elapsed / 60);\n                const seconds = elapsed % 60;\n                document.getElementById('processingTime_aiSmoke').textContent = \n                    `${minutes}:${seconds.toString().padStart(2, '0')}`;\n            }\n        }\n        \n        window.preload_ai_smoke_images = async function() {\n            try {\n                console.log('Starting enhanced image load...');\n                updateStatus_aiSmoke('Loading image list...', 'running');\n                \n                const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/ai_smoke/image_list`);\n                if (!response.ok) {\n                    throw new Error(`Failed to fetch image list: ${response.status}`);\n                }\n                \n                const data = await response.json();\n                console.log('Image list received:', data);\n                \n                const totalImages = data.input_images.length + data.output_images.length;\n                updateStatus_aiSmoke(`Loading input images...`, 'running');\n                \n                // Enhanced image loading with retry mechanism\n                function loadImageWithRetry(src, filename, imageType, maxRetries = 3, timeout = 15000) {\n                    return new Promise((resolve, reject) => {\n                        let attempts = 0;\n                        \n                        function attemptLoad() {\n                            attempts++;\n                            console.log(`Attempting to load ${filename} (${imageType}) (attempt ${attempts}/${maxRetries})`);                            \n                            const img = new Image();\n                            let timeoutId;\n                            \n                            img.onload = () => {\n                                clearTimeout(timeoutId);\n                                console.log(` Successfully loaded: ${filename} (${imageType})`);\n                                \n                                // Validate that the image actually loaded with content\n                                if (img.naturalWidth > 0 && img.naturalHeight > 0) {\n                                    // Store in appropriate cache\n                                    if (imageType === 'input') {\n                                        ai_smoke_InputImageCache[filename] = img;\n                                    } else {\n                                        ai_smoke_OutputImageCache[filename] = img;\n                                    }\n                                    resolve({ success: true, filename, imageType, attempts });\n                                } else {\n                                    console.warn(` Image loaded but has no dimensions: ${filename} (${imageType})`);\n                                    if (attempts < maxRetries) {\n                                        setTimeout(attemptLoad, 1000 * attempts);\n                                    } else {\n                                        reject(new Error(`Image has no dimensions after ${maxRetries} attempts: ${filename} (${imageType})`));\n                                    }\n                                }\n                            };\n                            \n                            img.onerror = () => {\n                                clearTimeout(timeoutId);\n                                console.error(` Failed to load: ${filename} (${imageType}) (attempt ${attempts})`);\n                                \n                                if (attempts < maxRetries) {\n                                    setTimeout(attemptLoad, 1000 * attempts);\n                                } else {\n                                    reject(new Error(`Failed to load after ${maxRetries} attempts: ${filename} (${imageType})`));\n                                }\n                            };\n                            \n                            // Set timeout for this attempt\n                            timeoutId = setTimeout(() => {\n                                console.warn(` Timeout loading: ${filename} (${imageType}) (attempt ${attempts})`);                                img.src = ''; // Cancel the request\n                                \n                                if (attempts < maxRetries) {\n                                    setTimeout(attemptLoad, 1000 * attempts); // Progressive delay\n                                } else {\n                                    reject(new Error(`Timeout after ${maxRetries} attempts: ${filename} (${imageType})`));\n                                }\n                            }, timeout);\n                            \n                            img.src = src;\n                        }\n                        \n                        attemptLoad();\n                    });\n                }\n                \n                // Validate images exist on server before attempting to load\n                async function validateImageExists(filename, type) {\n                    try {\n                        const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/ai_smoke/validate_image/${type}/${filename}`);\n                        if (response.ok) {\n                            const result = await response.json();\n                            return result.valid;\n                        }\n                        return false;\n                    } catch (error) {\n                        console.error(`Error validating image ${filename}:`, error);\n                        return false;\n                    }\n                }\n                \n                const loadPromises = [];\n                let validatedCount = 0;\n                \n                // Process input images\n                // Process input images\n                for (const filename of data.input_images) {\n                    const isValid = await validateImageExists(filename, 'input');\n                    if (isValid) {\n                        const src = `http://${FLASK_HOST}:${FLASK_PORT}/ai_smoke/images/input/${filename}`;\n                        loadPromises.push(loadImageWithRetry(src, filename, 'input'));\n                        validatedCount++;\n                    } else {\n                        console.warn(`Skipping invalid input image: ${filename}`);\n                    }\n                }\n\n                // Process output images\n                for (const filename of data.output_images) {\n                    const isValid = await validateImageExists(filename, 'output');\n                    if (isValid) {\n                        const src = `http://${FLASK_HOST}:${FLASK_PORT}/ai_smoke/images/output/${filename}`;\n                        loadPromises.push(loadImageWithRetry(src, filename, 'output'));\n                        validatedCount++;\n                    } else {\n                        console.warn(`Skipping invalid output image: ${filename}`);\n                    }\n                }\n                \n                console.log(`Validated ${validatedCount}/${totalImages} images, starting download...`);\n                updateStatus_aiSmoke(`Loading ${validatedCount} validated images...`, 'running');\n                \n                // Track progress\n                let loadedCount = 0;\n                const progressPromises = loadPromises.map(promise => \n                    promise.then(result => {\n                        loadedCount++;\n                        const percentage = Math.round((loadedCount / validatedCount) * 100);\n                        updateStatus_aiSmoke(`Loading images... ${loadedCount}/${validatedCount} (${percentage}%)`, 'running');\n                        return result;\n                    }).catch(error => {\n                        loadedCount++;\n                        const percentage = Math.round((loadedCount / validatedCount) * 100);\n                        updateStatus_aiSmoke(`Loading images... ${loadedCount}/${validatedCount} (${percentage}%)`, 'running');\n                        throw error;\n                    })\n                );\n                \n                // Wait for all images with detailed results\n                const results = await Promise.allSettled(progressPromises);\n                \n                const successful = results.filter(r => r.status === 'fulfilled');\n                const failed = results.filter(r => r.status === 'rejected');\n                \n                console.log(`Load completed: ${successful.length} successful, ${failed.length} failed`);\n                \n                // Log detailed failure information\n                if (failed.length > 0) {\n                    console.group('Failed image loads:');\n                    failed.forEach((result, index) => {\n                        console.error(`${index + 1}. ${result.reason.message}`);\n                    });\n                    console.groupEnd();\n                }\n                \n                // Log successful loads with retry information\n                if (successful.length > 0) {\n                    console.group('Successful image loads:');\n                    successful.forEach(result => {\n                        const { filename, imageType, attempts } = result.value;\n                        if (attempts > 1) {\n                            console.log(`${filename} (${imageType}) (required ${attempts} attempts)`);\n                        }\n                    });\n                    console.groupEnd();\n                }\n                \n                const successRate = Math.round((successful.length / validatedCount) * 100);\n                \n                if (failed.length === 0) {\n                    // updateStatus_aiSmoke(`All input images loaded successfully (${successful.length}/${validatedCount})`, 'ready');\n                    updateStatus_aiSmoke(`All input images loaded successfully`, 'ready');\n                } else if (successful.length > 0) {\n                    // updateStatus_aiSmoke(`Images loaded: ${successful.length}/${validatedCount} (${successRate}%) - ${failed.length} failed`, 'ready');\n                    updateStatus_aiSmoke(`All input images loaded successfully`, 'ready');\n                } else {\n                    updateStatus_aiSmoke('Failed to load input images - check console for details', 'error');\n                }\n                \n                // // Store validation results for later use\n                // window.imageValidationResults = {\n                //     total: validatedCount,\n                //     successful: successful.length,\n                //     failed: failed.length,\n                //     successRate: successRate\n                // };\n                \n                // console.log('Enhanced image preload completed - ready for display');\n\n                // Store validation results for later use\n                window.imageValidationResults = {\n                    total: validatedCount,\n                    successful: successful.length,\n                    failed: failed.length,\n                    successRate: successRate\n                };\n\n                console.log('Input image load completed - ready for display');\n                \n                // numToCheck = 300;\n                // // Validate first 100 input images\n                // const inputValidation = validateFirst100InputImages(numToCheck);\n\n                // // Update final status based on validation\n                // if (failed.length === 0 && inputValidation.success) {\n                //     // updateStatus_aiSmoke(`All input images loaded and validated successfully (${successful.length}/${validatedCount})`, 'ready');\n                //     updateStatus_aiSmoke(`All input images loaded and validated`, 'ready');\n                //     console.log(`All first ${numToCheck} input images are present in cache`);\n                // } else if (failed.length === 0 && !inputValidation.success) {\n                //     updateStatus_aiSmoke(`Input images loaded: ${successful.length}/${validatedCount} - Missing ${inputValidation.missing}/${numToCheck} input images`, 'error');\n                //     console.warn(`Missing ${inputValidation.missing}/${numToCheck} input images`);\n                // } else if (successful.length > 0) {\n                //     updateStatus_aiSmoke(`Input images loaded: ${successful.length}/${validatedCount} (${successRate}%) - ${failed.length} failed, ${inputValidation.missing}/${numToCheck} input missing`, 'error');\n                //     console.warn(`Missing ${inputValidation.missing}/${numToCheck} input images`);\n                // } else {\n                //     updateStatus_aiSmoke('Failed to load input images - check console for details', 'error');\n                //     console.error('Failed to load input images - check console for details');\n                // }\n                                \n            } catch (error) {\n                console.error('Error in loading:', error);\n                updateStatus_aiSmoke('Error loading input images - check network connection', 'error');\n            }\n        }\n\n        // function validateFirst100InputImages(numToCheck = 100) {\n        //     console.log(`Validating first ${numToCheck} input images in cache...`);\n            \n        //     const missingImages = [];\n        //     const presentImages = [];\n            \n        //     // Check images 1.webp through 100.webp\n        //     for (let i = 1; i <= numToCheck; i++) {\n        //         const filename = `${i}.webp`;\n        //         if (ai_smoke_InputImageCache[filename]) {\n        //             presentImages.push(filename);\n        //         } else {\n        //             missingImages.push(filename);\n        //         }\n        //     }\n            \n        //     // Log results\n        //     console.log(`Input image validation results:`);\n        //     console.log(` Present: ${presentImages.length}/${numToCheck} images`);\n            \n        //     if (missingImages.length > 0) {\n        //         console.warn(` Missing: ${missingImages.length}/${numToCheck} images`);\n        //         console.group('Missing input images:');\n        //         missingImages.forEach(filename => {\n        //             console.warn(`- ${filename}`);\n        //         });\n        //         console.groupEnd();\n                \n        //         // Update status to show validation results\n        //         updateStatus_aiSmoke(`Input images loaded with warnings: ${presentImages.length}/${numToCheck} input images found`, 'error');\n        //     } else {\n        //         console.log(` All first ${numToCheck} input images are present in cache`);\n        //         updateStatus_aiSmoke(`All input images loaded successfully - First ${numToCheck} input images validated`, 'ready');\n        //     }\n            \n        //     // Store validation results\n        //     window.inputImageValidation = {\n        //         total: numToCheck,\n        //         present: presentImages.length,\n        //         missing: missingImages.length,\n        //         missingList: missingImages,\n        //         presentList: presentImages\n        //     };\n            \n        //     return {\n        //         success: missingImages.length === 0,\n        //         present: presentImages.length,\n        //         missing: missingImages.length,\n        //         missingList: missingImages\n        //     };\n        // }\n\n        window.run_ai_smoke = function() {\n            if (isRunning_aiSmoke) return;\n            \n            isRunning_aiSmoke = true;\n            startTime_aiSmoke = new Date();\n            startProcessingTimer();\n            \n            updateStatus_aiSmoke('Starting ai smoke...', 'running');\n            updateButtons_aiSmoke();\n            \n            // Clear previous images\n            clearImages_aiSmoke();\n            \n            try {\n                fetch(`http://${FLASK_HOST}:${FLASK_PORT}/send_message`, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({ message: `run_ai_smoke:${numAICoreRun}` })\n                })\n                .then(response => response.json())\n                .then(data => {\n                    console.log(\"Command sent successfully:\", data);\n                    // startProgressPolling();\n                    startAICoreMonitoring();  // wait for AI cores\n                    startCompletionPolling();\n                })\n                .catch(error => {\n                    console.error(\"Error sending command:\", error);\n                    updateStatus_aiSmoke('Error starting detection', 'error');\n                    isRunning_aiSmoke = false;\n                    updateButtons_aiSmoke();\n                });\n            } catch (error) {\n                console.error(\"Error:\", error);\n                updateStatus_aiSmoke('Error starting detection', 'error');\n                isRunning_aiSmoke = false;\n                updateButtons_aiSmoke();\n            }\n        }\n        \n        window.clear_ai_smoke = function() {\n            stopLocalImageDisplay();\n            stopProcessingTimer();\n            stopAICoreMonitoring();\n            stopProgressPolling();\n            isRunning_aiSmoke = false;\n            startTime_aiSmoke = null;\n            \n            clearImages_aiSmoke();\n            updateStatus_aiSmoke('Cleared', 'ready');\n            updateButtons_aiSmoke();\n            \n            // document.getElementById('processStatus').textContent = 'Idle';\n            // document.getElementById('latestOutput').textContent = 'None';\n            document.getElementById('processed_images_aiSmoke').textContent = '-';\n            document.getElementById('processingTime_aiSmoke').textContent = '-';\n            \n            // Send clear command to server\n            fetch(`http://${FLASK_HOST}:${FLASK_PORT}/send_message`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({ message: \"clear_ai_smoke\" })\n            })\n            .catch(error => console.error(\"Error sending clear command:\", error));\n        }\n        \n        // function startProgressPolling() {\n        //     if (pollInterval_aiSmoke) clearInterval(pollInterval_aiSmoke);\n            \n        //     pollInterval_aiSmoke = setInterval(async () => {\n        //         try {\n        //             const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/ai_smoke/progress`);\n        //             const data = await response.json();\n                    \n        //             if (data.type) {\n        //                 handleProgressUpdate(data);\n        //             }\n        //         } catch (error) {\n        //             console.error('Error polling progress:', error);\n        //         }\n        //     }, 30);\n        // }\n\n        function startCompletionPolling() {\n            if (pollInterval_aiSmoke) clearInterval(pollInterval_aiSmoke);\n            \n            pollInterval_aiSmoke = setInterval(async () => {\n                try {\n                    const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/ai_smoke/progress`);\n                    const data = await response.json();\n                    \n                    if (data.type === 'ai_smoke_complete') {\n                        handleCompletion();\n                        document.getElementById('processed_images_aiSmoke').textContent = '1,239';\n                    } else if (data.type === 'ai_smoke_error') {\n                        handleError(data.error);\n                    }\n                } catch (error) {\n                    console.error('Error polling completion:', error);\n                }\n            }, 500); // Poll every 500ms\n        }\n        \n        function stopProgressPolling() {\n            if (pollInterval_aiSmoke) {\n                clearInterval(pollInterval_aiSmoke);\n                pollInterval_aiSmoke = null;\n            }\n        }\n        \n        // function handleProgressUpdate(data) {\n        //     console.log('Progress update:', data);\n            \n        //     switch (data.type) {\n        //         case 'small_obj_detect_start':\n        //             updateStatus_aiSmoke('Detection started', 'running');\n        //             // document.getElementById('processStatus').textContent = 'Running';\n        //             break;\n                    \n        //         case 'small_obj_detect_progress':\n        //             // Log what we're trying to display\n        //             // console.log(`Attempting1111 input=${data.input_image}, output=${data.output_image}`);\n                    \n        //             // Check if images exist in cache before displaying\n        //             if (!ai_smoke_InputImageCache[data.input_image]) {\n        //                 console.warn(`Input image ${data.input_image} not found in input cache`);\n        //             }\n        //             if (!ai_smoke_OutputImageCache[data.output_image]) {\n        //                 console.warn(`Output image ${data.output_image} not found in output cache`);\n        //             }\n                                        \n        //             displayImagePair(data.input_image, data.output_image);\n        //             // console.log(`Attempting2222 input=${data.input_image}, output=${data.output_image}`);\n        //             // document.getElementById('latestOutput').textContent = data.output_image;\n\n        //             updateprocessingTime_aiSmoke();\n        //             // console.log(`Attempting3333 input=${data.input_image}, output=${data.output_image}`);\n\n        //             break;\n                    \n        //         case 'small_obj_detect_complete':\n        //             updateStatus_aiSmoke('Detection completed successfully', 'ready');\n        //             // document.getElementById('processStatus').textContent = 'Completed';\n        //             isRunning_aiSmoke = false;\n        //             updateButtons_aiSmoke();\n        //             stopProgressPolling();\n        //             break;\n                    \n        //         case 'small_obj_detect_error':\n        //             updateStatus_aiSmoke(`Error: ${data.error}`, 'error');\n        //             // document.getElementById('processStatus').textContent = 'Error';\n        //             isRunning_aiSmoke = false;\n        //             updateButtons_aiSmoke();\n        //             stopProgressPolling();\n        //             break;\n        //     }\n        // }\n\n        function handleCompletion() {\n            stopLocalImageDisplay();\n            stopProcessingTimer();\n            stopAICoreMonitoring();\n            updateStatus_aiSmoke('Detection completed successfully', 'ready');\n            isRunning_aiSmoke = false;\n            updateButtons_aiSmoke();\n            stopProgressPolling();\n        }\n\n        function handleError(errorMsg) {\n            stopLocalImageDisplay();\n            stopProcessingTimer();\n            stopAICoreMonitoring();\n            updateStatus_aiSmoke(`Error: ${errorMsg}`, 'error');\n            isRunning_aiSmoke = false;\n            updateButtons_aiSmoke();\n            stopProgressPolling();\n        }\n        \n        function displayImagePair(inputFilename, outputFilename) {\n            console.log(`Displaying images: input=${inputFilename}, output=${outputFilename}`);\n            const inputContainer = document.getElementById('inputImageContainer_aiSmoke');\n            const outputContainer = document.getElementById('outputImageContainer_aiSmoke');\n            const inputInfo = document.getElementById('inputImageInfo_aiSmoke');\n            const outputInfo = document.getElementById('outputImageInfo_aiSmoke');\n            \n            // Function to create and display image with fallback\n            function displayImage(filename, type, container, infoElement) {\n                let cachedImg;\n                \n                // Get image from appropriate cache\n                if (type === 'input') {\n                    cachedImg = ai_smoke_InputImageCache[filename];\n                } else {\n                    cachedImg = ai_smoke_OutputImageCache[filename];\n                }\n                \n                if (cachedImg && cachedImg.complete && cachedImg.naturalWidth > 0) {\n                    // Create a new image element to display\n                    const displayImg = document.createElement('img');\n                    displayImg.src = cachedImg.src;\n                    \n                    container.innerHTML = '';\n                    container.appendChild(displayImg);\n                    // infoElement.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)}: ${filename}`;\n                    infoElement.textContent = ``;\n                    \n                    // Add error handling for display\n                    displayImg.onerror = () => {\n                        console.error(`Failed to display ${type} image: ${filename}`);\n                        container.innerHTML = `<div class=\"ai-smoke-widget-image-placeholder\">Failed to display ${type} image</div>`;\n                    };\n                    \n                    return true;\n                } else {\n                    console.warn(`${type} image not available in cache: ${filename}`);\n                    container.innerHTML = `<div class=\"ai-smoke-widget-image-placeholder\">${type.charAt(0).toUpperCase() + type.slice(1)} image not available</div>`;\n                    return false;\n                }\n            }\n            \n            // Display both images\n            const inputDisplayed = displayImage(inputFilename, 'input', inputContainer, inputInfo);\n            const outputDisplayed = displayImage(outputFilename, 'output', outputContainer, outputInfo);\n            \n            // Log display status\n            if (inputDisplayed && outputDisplayed) {\n                console.log(`Successfully displayed both images: ${inputFilename} and ${outputFilename}`);\n            } else {\n                console.warn(`Partial display: input=${inputDisplayed}, output=${outputDisplayed}`);\n            }\n        }\n    \n    })(); // End of IIFE\n    </script>\n</body>\n</html>",
            "mode": "html"
          },
          "pluginVersion": "12.1.0",
          "title": "",
          "transparent": true,
          "type": "text"
        }
      ],
      "title": "AI Smoke",
      "type": "row"
    },
    {
      "collapsed": false,
      "gridPos": {
        "h": 1,
        "w": 24,
        "x": 0,
        "y": 49
      },
      "id": 108,
      "panels": [],
      "title": "Networking",
      "type": "row"
    },
    {
      "gridPos": {
        "h": 4,
        "w": 2,
        "x": 0,
        "y": 50
      },
      "id": 210,
      "options": {
        "code": {
          "language": "plaintext",
          "showLineNumbers": false,
          "showMiniMap": false
        },
        "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Option Selector</title>\n    <style>\n        \n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"dropdown-container\">\n            <div class=\"box-container no-border-background\">\n                <h3>1G Copper Port</h3>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        \n    </script>\n</body>\n</html>\n",
        "mode": "html"
      },
      "pluginVersion": "12.1.0",
      "type": "text"
    },
    {
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 2,
        "y": 50
      },
      "id": 200,
      "options": {
        "code": {
          "language": "plaintext",
          "showLineNumbers": false,
          "showMiniMap": false
        },
        "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Option Selector</title>\n    <style>\n        \n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"dropdown-container\">\n            <div class=\"box-container no-border-background\">\n                <p>Test Duration</p>\n                <select id=\"durationDropdown_LwEthOnb\"\n                    onchange=\"setTestDurationLwEthOnb()\">\n                </select>\n                <div class=\"status-container\">\n                    <p id=\"statusNet_LwEthOnb\">&nbsp;</p>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        populateDurationDropdownLwEthOnb();\n    </script>\n</body>\n</html>\n",
        "mode": "html"
      },
      "pluginVersion": "12.1.0",
      "transparent": true,
      "type": "text"
    },
    {
      "gridPos": {
        "h": 4,
        "w": 3,
        "x": 5,
        "y": 50
      },
      "id": 230,
      "options": {
        "code": {
          "language": "plaintext",
          "showLineNumbers": false,
          "showMiniMap": false
        },
        "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Option Selector</title>\n    <style>\n        \n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"dropdown-container\">\n            <div class=\"box-container no-border-background\">\n                <p>Bandwidth</p>\n                <select id=\"bwDropdown_LwEthOnb\"\n                    onchange=\"setBwLwEthOnb()\">\n                </select>\n                <div class=\"status-container\">\n                    <p id=\"statusNet_LwEthOnbBw\">&nbsp;</p>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        populateBwDropdownLwEthOnb();\n    </script>\n</body>\n</html>\n",
        "mode": "html"
      },
      "pluginVersion": "12.1.0",
      "transparent": true,
      "type": "text"
    },
    {
      "gridPos": {
        "h": 4,
        "w": 4,
        "x": 8,
        "y": 50
      },
      "id": 209,
      "options": {
        "code": {
          "language": "plaintext",
          "showLineNumbers": false,
          "showMiniMap": false
        },
        "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <style>\n        html, body {\n            height: 100%;\n            margin: 0;\n            padding: 0;\n            overflow: hidden;\n            display: flex;\n            flex-direction: column;\n        }\n\n        .container {\n            display: flex;\n            align-items: flex-start;\n            gap: 20px;\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            max-width: 100%;\n            padding-left: 0;\n            padding-right: 0;\n        }\n\n        .dropdown-container {\n            display: flex;\n            flex-direction: column;\n            border-radius: 2px;\n        }\n\n        select {\n            font-size: 14px;\n            /* padding: 10px; */\n            width: 270px;\n            height: 40px;\n            display: flex;\n            border-radius: 2px;\n        }\n\n        .status-container {\n            font-size: 14px;\n            height: 20px;\n            margin-bottom: 5px;\n            font-weight: bold;\n        }\n\n        .image-container {\n            width: 1000px;\n            height: 650px;\n            display: flex;\n            flex-direction: column;\n            overflow: hidden;\n            margin: 0;\n            padding: 0;\n        }\n\n        #processedImage {\n            display: none;\n            max-width: none;\n            max-height: none;\n            object-fit: contain;\n        }\n\n        .button-container {\n            display: flex;\n            justify-content: left;\n            gap: 40px;\n            margin-top: 20px;\n            margin-left: 20px;\n            width: min-content;\n        }\n\n        /* Style for all buttons */\n        .button-container button {\n            width: 80px;\n            height: 40px;\n            border-radius: 2px;\n            border: none;\n            cursor: pointer;\n        }\n\n        /* First container's buttons: Refresh and Load */\n        .button-container:nth-child(1) button {\n            background-color: #2372cc;\n            color: white;\n        }\n\n        .button-container:nth-child(1) button:hover {\n            background-color: #3696ff;\n        }\n\n        .button-container:nth-child(1) button:nth-child(2) {\n            background-color: #218838;\n            color: white;\n        }\n\n        .button-container:nth-child(1) button:nth-child(2):hover {\n            background-color: #34d058;\n        }\n\n        /* Second container's buttons: Run and Reset */\n        .button-container:nth-child(2) button:nth-child(1) {\n            background-color: #2372cc;\n            color: white;\n        }\n\n        .button-container:nth-child(2) button:nth-child(1):hover {\n            background-color: #3696ff;\n        }\n\n        .button-container:nth-child(2) button:nth-child(2) {\n            background-color: #ca2715;\n            color: white;\n        }\n\n        .button-container:nth-child(2) button:nth-child(2):hover {\n            background-color: #ff4c47;\n        }\n        \n        /* Make each <p> for the information data a flex container for label and data alignment */\n        .status-info p {\n            display: flex;\n            justify-content: space-between; /* Distribute the label and data across the width */\n            align-items: center; /* Vertically center both the label and the data */\n        }\n\n        #durationDropdown_LwEthOnb {\n            width: 200px;\n        }\n        #bwDropdown_LwEthOnb {\n            width: 200px;\n        }\n        #durationDropdown_LwEthAdt {\n            width: 200px;\n        }\n        #bwDropdown_LwEthAdt {\n            width: 200px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"dropdown-container\">\n            <div class=\"box-container no-border-background\">\n                <div class=\"button-container\">\n                    \n                </div>\n                <div class=\"button-container\">\n                    <button onclick=\"btnLwEthOnbRunClick()\">Run</button>\n                    <button onclick=\"btnLwEthOnbResetClick()\">Reset</button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script>\n        DOCKER_INTERFACE_ID = \"docker0\"\n        FM_INTERFACE_ID = \"fm1-mac3\"\n        LOCAL_INTERFACE_ID = \"lo\"\n        VIRTUAL_INTERFACE_ID = \"virbr0\"\n\n        FLASK_PORT = 5001;\n        FLASK_HOST = \"localhost\"\n        \n        let testDurationLwEthOnb = null; // Variable to store selected duration\n        let testDurationUpEthOnb = null;\n        let testDurationLwEthAdt = null;\n        let testDurationUpEthAdt = null;\n\n        let lastTifFilename = \"lastFile\"; // Store the last processed tif_filename\n\n\n        populateBwDropdownLwEthOnb();\n        populateDurationDropdownLwEthOnb();\n        \n        \n        function fetchFileList() {\n            const statusElement = document.getElementById(\"status\");\n            statusElement.textContent = \"Fetching file list...\"; // Show status message\n\n            fetch(`http://${FLASK_HOST}:${FLASK_PORT}/send_message`, {\n                method: \"POST\",\n                headers: { \"Content-Type\": \"application/json\" },\n                body: JSON.stringify({ message: \"4\" })  \n            })\n            .then(() => {\n                setTimeout(() => {\n                    fetch(`http://${FLASK_HOST}:${FLASK_PORT}/get_cphd_files`)\n                        .then(response => response.json())\n                        .then(data => {\n                            console.log(\"Fetched CPHD files:\", data.files);\n\n                            const select = document.getElementById(\"menuDropdown\");\n                            select.innerHTML = ''; // Clear existing options\n\n                            if (data.files.length === 0) {\n                                statusElement.textContent = \"No CPHD files found.\";\n                                select.innerHTML = '<option value=\"\" disabled>No files available</option>';\n                                document.getElementById(\"fileSize\").textContent = \"N/A\";\n                            } else {\n                                statusElement.textContent = `Fetched ${data.files.length} file(s).`;\n\n                                data.files.forEach(file => {\n                                    const option = document.createElement('option');\n                                    option.value = file;\n                                    option.textContent = file;\n                                    select.appendChild(option);\n                                });\n                            }\n                        })\n                        .catch(error => {\n                            console.error('Error fetching CPHD files:', error);\n                            statusElement.textContent = \"Error fetching file list.\";\n                        });\n                }, 500);\n            })\n            .catch(error => {\n                console.error(\"Error sending fetch command:\", error);\n                statusElement.textContent = \"Error requesting file fetch.\";\n            });\n        }\n\n        function fetchFileSize() {\n            const selectedFile = document.getElementById(\"menuDropdown\").value;\n            if (!selectedFile) return;\n\n            fetch(`http://${FLASK_HOST}:${FLASK_PORT}/get_cphd_file_properties`)\n                .then(response => response.json())\n                .then(data => {\n                    if (data.files.filename === selectedFile) {\n                        document.getElementById(\"fileSize\").textContent = data.files.size;\n                        document.getElementById(\"imageSize\").textContent = data.files.metadata.numRows + \" x \" + data.files.metadata.numColumns;\n                        document.getElementById(\"resolution\").textContent = data.files.metadata.groundResolution.toFixed(2) + \" meters\";\n                    } else {\n                        document.getElementById(\"fileSize\").textContent = \"N/A\";\n                        document.getElementById(\"imageSize\").textContent = \"N/A\";\n                        document.getElementById(\"resolution\").textContent = \"N/A\";\n                        document.getElementById(\"areaSize\").textContent = \"N/A\";\n                    }\n                })\n                .catch(error => {\n                    console.error(\"Error fetching file size:\", error);\n                    document.getElementById(\"fileSize\").textContent = \"N/A\";\n                    document.getElementById(\"imageSize\").textContent = \"N/A\";\n                    document.getElementById(\"resolution\").textContent = \"N/A\";\n                    document.getElementById(\"areaSize\").textContent = \"N/A\";\n                });\n        }\n\n        function fetchProcessedFile() {\n            fetch(`http://${FLASK_HOST}:${FLASK_PORT}/images/tif_image.webp`)\n                .then(response => {\n                    if (!response.ok) {\n                        throw new Error(\"Failed to fetch image.\");\n                    }\n                    return response.blob();\n                })\n                .then(imageBlob => {\n                    const imageUrl = URL.createObjectURL(imageBlob);\n                    document.getElementById(\"processedImage1\").src = imageUrl;\n                    document.getElementById(\"processedImage2\").src = imageUrl;\n                    document.getElementById(\"processedImage1\").style.display = \"block\";\n                    document.getElementById(\"processedImage2\").style.display = \"block\";\n                })\n                .catch(error => {\n                    console.error(\"Error fetching processed image:\", error);\n                    document.getElementById(\"processedImage1\").style.display = \"none\";\n                    document.getElementById(\"processedImage2\").style.display = \"none\";\n                });\n        }\n\n        function sendLoad() {\n            const selectedOption = document.getElementById(\"menuDropdown\").value;\n            const statusElement = document.getElementById(\"status\");\n\n            if (!selectedOption) {\n                statusElement.textContent = \"Please select a file first.\";\n                return;\n            }\n\n            fetch(`http://${FLASK_HOST}:${FLASK_PORT}/send_message`, {\n                method: \"POST\",\n                headers: { \"Content-Type\": \"application/json\" },\n                body: JSON.stringify({ message: `SIZE:${selectedOption}` })\n            })\n            .then(response => response.json())\n            .then(data => {\n                statusElement.textContent = \"Command sent... Load.\";\n                fetchFileSize(); // Fetch file size immediately after sending message\n            })\n            .catch(error => {\n                console.error(\"Error:\", error);\n                statusElement.textContent = \"Error sending command.\";\n            });\n            // Reset images\n            document.getElementById(\"processedImage1\").src = \"\";\n            document.getElementById(\"processedImage2\").src = \"\";\n            // Reset output properties\n            document.getElementById(\"outFileSize\").textContent = \"N/A\";\n            document.getElementById(\"reductionFactor\").textContent = \"N/A\";\n            document.getElementById(\"sizeCompared\").textContent = \"N/A\";\n        }\n\n        async function sendRun() {\n            lastTifFilename = null; // Force re-fetch and update\n            \n            const selectedOption = document.getElementById(\"menuDropdown\").value;\n            const statusElement = document.getElementById(\"status\");\n        \n            if (!selectedOption) {\n                statusElement.textContent = \"Please select a file first.\";\n                return;\n            }\n        \n            try {\n                // Send the \"RUN\" command\n                await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/send_message`, {\n                    method: \"POST\",\n                    headers: { \"Content-Type\": \"application/json\" },\n                    body: JSON.stringify({ message: `RUN:${selectedOption}` })\n                });\n        \n                statusElement.textContent = \"Command sent... Run\";\n        \n                // Reset images\n                document.getElementById(\"processedImage1\").src = \"\";\n                document.getElementById(\"processedImage2\").src = \"\";\n                // Reset output properties\n                document.getElementById(\"outFileSize\").textContent = \"N/A\";\n                document.getElementById(\"reductionFactor\").textContent = \"N/A\";\n                document.getElementById(\"sizeCompared\").textContent = \"N/A\";\n        \n                // Set timeout\n                const startTime = Date.now();\n                const timeout = 30 * 1000; // 25 seconds\n                let fileUpdated = false;\n        \n                while (!fileUpdated && (Date.now() - startTime < timeout)) {\n                    // Fetch the output file properties\n                    const response = await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/get_tif_file_properties`);\n                    const data = await response.json();\n        \n                    // Check if tif_filename has changed\n                    if (data.files.tif_filename && data.files.tif_filename !== lastTifFilename) {\n                        statusElement.textContent = \"Getting output properties ... Data Fetched.\";\n        \n                        // Update output file properties\n                        document.getElementById(\"outFileSize\").textContent = data.files.size;\n                        document.getElementById(\"reductionFactor\").textContent = \"x\" + data.files.reduction_scale + \" or \" + data.files.reduction_factor + \"%\";\n                        document.getElementById(\"sizeCompared\").textContent = data.files.size_compared + \"%\";\n        \n                        // Fetch the image after properties are updated\n                        fetchProcessedFile();\n        \n                        // Update the last processed filename\n                        lastTifFilename = data.files.tif_filename;\n        \n                        fileUpdated = true;\n                    } else {\n                        statusElement.textContent = \"Waiting for processed file...\";\n                        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait for 2 seconds before retrying\n                    }\n                }\n        \n                if (!fileUpdated) {\n                    statusElement.textContent = \"Getting output properties ... Timeout.\";\n                } else {\n                    statusElement.textContent = \"Getting output properties ... Done.\";\n                }\n            } catch (error) {\n                console.error(\"Error:\", error);\n                statusElement.textContent = \"Error sending command.\";\n            }\n        }\n        \n\n        function resetMenu() {\n            lastTifFilename = \"lastFile\";\n\n            fetch(`http://${FLASK_HOST}:${FLASK_PORT}/send_message`, {\n                method: \"POST\",\n                headers: { \"Content-Type\": \"application/json\" },\n                body: JSON.stringify({ message: \"3\"})\n            })\n            .then(response => response.json())\n            .then(data => {\n                statusElement.textContent = \"Command sent... Reset.\";\n            })\n            .catch(error => {\n                console.error(\"Error:\", error);\n                statusElement.textContent = \"Error sending command.\";\n            });\n            document.getElementById(\"menuDropdown\").innerHTML = '<option value=\"\" disabled selected>Click \"Refresh\" to fetch</option>';\n            document.getElementById(\"status\").textContent = \"\";\n            document.getElementById(\"fileSize\").textContent = \"N/A\";\n            document.getElementById(\"imageSize\").textContent = \"N/A\";\n            document.getElementById(\"resolution\").textContent = \"N/A\";\n            document.getElementById(\"areaSize\").textContent = \"N/A\";\n            // Reset images\n            document.getElementById(\"processedImage1\").src = \"\";\n            document.getElementById(\"processedImage2\").src = \"\";\n            // Reset output properties\n            document.getElementById(\"outFileSize\").textContent = \"N/A\";\n            document.getElementById(\"reductionFactor\").textContent = \"N/A\";\n            document.getElementById(\"sizeCompared\").textContent = \"N/A\";\n        }\n        \n        // ================================================================================================================\n        // ========================================= Lower Ethernet Port on board =========================================\n        // ================================================================================================================\n        async function btnLwEthOnbRunClick(triggeredBySync = false) {\n            const selectedTestDuration = testDurationLwEthOnb; // Use the global testDuration variable\n            const statusNetElement = document.getElementById(\"statusNet_LwEthOnb\");\n            const bwDropdown = document.getElementById(\"bwDropdown_LwEthOnb\");\n            const selectedBwValue = bwDropdown.value;\n\n            document.getElementById(\"upBW_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"upLat_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"upLostTotal_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"downBW_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"downLat_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"downLostTotal_LwEthOnb\").textContent = \"N/A\";\n\n            if (!selectedTestDuration) {\n                statusNetElement.textContent = \"Please select a duration\";\n                if (!bwDropdown || !selectedBwValue || selectedBwValue === \"default\") {\n                    document.getElementById(\"statusNet_LwEthOnbBw\").textContent = \"Please select a bandwidth\";\n                    return;\n                }\n                return;\n            }\n            if (!bwDropdown || !selectedBwValue || selectedBwValue === \"default\") {\n                document.getElementById(\"statusNet_LwEthOnbBw\").textContent = \"Please select a bandwidth\";\n                if (!selectedTestDuration) {\n                    statusNetElement.textContent = \"Please select a duration\";\n                    return;\n                }\n                return;\n            }\n            if (!triggeredBySync) {\n                localStorage.setItem(\"panelSync\", JSON.stringify({\n                    type: \"run\"\n                }));\n                // Send the NETRUN message via POST request\n                await fetch(`http://${FLASK_HOST}:${FLASK_PORT}/send_message`, {\n                    method: \"POST\",\n                    headers: { \"Content-Type\": \"application/json\" },\n                    body: JSON.stringify({ message: `NETRUN:${selectedTestDuration}:${FM_INTERFACE_ID}` })\n                });\n                statusNetElement.textContent = \"Waiting for results...\";\n                \n                await new Promise(resolve => setTimeout(resolve, testDurationLwEthOnb*1000*2+5000));\n\n                fetch(`http://${FLASK_HOST}:${FLASK_PORT}/iperf3/lw_eth_onb_results`)\n                .then(response => response.json())\n                .then(data => {\n                    // console.log('Wating for results... Done');\n                    // console.log('get net test down result')\n                    // stream = data.up.sum_sent;\n                    // console.log(stream);\n\n                    // if (selectedBwValue == 10000) {\n                    //     bitsPerSecondMbit = stream.bits_per_second / 1e6;   // Convert bits_per_second to Mbit/sec (divide by 1e6)\n                    //     document.getElementById('downBW_LwEthOnb').textContent = `${bitsPerSecondMbit.toFixed(2)} Mbits/sec`;\n                    // }\n                    // else {\n                    //     bitsPerSecondMbit = stream.bits_per_second / 1e6;   // Convert bits_per_second to Mbit/sec (divide by 1e6)\n                    //     jitterMs = stream.jitter_ms;\n                    //     lostPackets = stream.lost_packets * 11584 / 1000000000;\n                    //     totalPackets = stream.packets * 11584 / 1000000000;\n                    //     lostPercent = stream.lost_percent;\n\n                    //     document.getElementById('downBW_LwEthOnb').textContent = `${bitsPerSecondMbit.toFixed(2)} Mbits/sec`;\n                    //     document.getElementById('downLat_LwEthOnb').textContent = `${jitterMs.toFixed(4)} ms`;\n                    //     document.getElementById('downLostTotal_LwEthOnb').textContent = `${lostPackets.toFixed(4)}/${totalPackets.toFixed(4)} Gbits (${lostPercent.toFixed(2)}%)`;\n                    // }\n                    \n                    // console.log('get net test up result')\n                    // stream = data.down.sum_received;\n                    // console.log(stream);\n\n                    // if (selectedBwValue == 10000) {\n                    //     bitsPerSecondMbit = stream.bits_per_second / 1e6;   // Convert bits_per_second to Mbit/sec (divide by 1e6)\n                    //     document.getElementById('upBW_LwEthOnb').textContent = `${bitsPerSecondMbit.toFixed(2)} Mbits/sec`;\n                    // }\n                    // else {\n                    //     bitsPerSecondMbit = stream.bits_per_second / 1e6;   // Convert bits_per_second to Mbit/sec (divide by 1e6)\n                    //     jitterMs = stream.jitter_ms;\n                    //     lostPackets = stream.lost_packets * 11584 / 1000000000;\n                    //     totalPackets = stream.packets * 11584 / 1000000000;\n                    //     lostPercent = stream.lost_percent;\n\n                    //     document.getElementById('upBW_LwEthOnb').textContent = `${bitsPerSecondMbit.toFixed(2)} Mbits/sec`;\n                    //     document.getElementById('upLat_LwEthOnb').textContent = `${jitterMs.toFixed(4)} ms`;\n                    //     document.getElementById('upLostTotal_LwEthOnb').textContent = `${lostPackets.toFixed(4)}/${totalPackets.toFixed(4)} Gbits (${lostPercent.toFixed(2)}%)`;\n                    // }\n\n                    updateResultsLwEthOnb(data);\n                    localStorage.setItem(\"panelResults\", JSON.stringify({\n                        interface: \"LwEth10GbE\",\n                        data: data\n                    }));\n                })\n                .catch(error => {\n                    statusNetElement.textContent = \"Test run error\";\n                    console.error('Error fetching the data:', error);\n                });\n            }\n            else {\n                statusNetElement.textContent = \"Waiting for results...\";\n            }\n        }\n\n        function updateResultsLwEthOnb(data) {\n            // Extract the relevant data from the JSON response\n            const streamUp = data.down.sum_received;\n            const streamDown = data.up.sum_sent;\n\n            const bwDropdown = document.getElementById(\"bwDropdown_LwEthOnb\");\n            const selectedBwValue = bwDropdown.value;\n\n            if (selectedBwValue == 10000) {\n                const downBW = (streamDown.bits_per_second / 1e6).toFixed(2);   // Convert bits_per_second to Mbit/sec (divide by 1e6)\n                const upBW = (streamUp.bits_per_second / 1e6).toFixed(2);\n                document.getElementById('downBW_LwEthOnb').textContent = `${downBW} Mbits/sec`;\n                document.getElementById('upBW_LwEthOnb').textContent = `${upBW} Mbits/sec`;\n            } \n            else {\n                let bitsPerSecondMbit, jitterMs, lostPackets, totalPackets, lostPercent;\n\n                bitsPerSecondMbit = streamDown.bits_per_second / 1e6;\n                jitterMs = streamDown.jitter_ms;\n                lostPackets = streamDown.lost_packets * 11584 / 1000000000;\n                totalPackets = streamDown.packets * 11584 / 1000000000;\n                lostPercent = streamDown.lost_percent;\n\n                document.getElementById('downBW_LwEthOnb').textContent = `${bitsPerSecondMbit.toFixed(2)} Mbits/sec`;\n                document.getElementById('downLat_LwEthOnb').textContent = `${jitterMs.toFixed(4)} ms`;\n                document.getElementById('downLostTotal_LwEthOnb').textContent = `${lostPackets.toFixed(4)}/${totalPackets.toFixed(4)} Gbits (${lostPercent.toFixed(2)}%)`;\n\n                bitsPerSecondMbit = streamUp.bits_per_second / 1e6;\n                jitterMs = streamUp.jitter_ms;\n                lostPackets = streamUp.lost_packets * 11584 / 1000000000;\n                totalPackets = streamUp.packets * 11584 / 1000000000;\n                lostPercent = streamUp.lost_percent;\n\n                document.getElementById('upBW_LwEthOnb').textContent = `${bitsPerSecondMbit.toFixed(2)} Mbits/sec`;\n                document.getElementById('upLat_LwEthOnb').textContent = `${jitterMs.toFixed(4)} ms`;\n                document.getElementById('upLostTotal_LwEthOnb').textContent = `${lostPackets.toFixed(4)}/${totalPackets.toFixed(4)} Gbits (${lostPercent.toFixed(2)}%)`;\n            }\n            document.getElementById(\"statusNet_LwEthOnb\").textContent = \"Waiting for results... Done\";\n        }\n        \n        function btnLwEthOnbResetClick(triggeredBySync = false) {\n            testDurationLwEthOnb = null;\n\n            // Reset dropdowns to default option (index 0)\n            const durationDropdown = document.getElementById(\"durationDropdown_LwEthOnb\");\n            const bwDropdown = document.getElementById(\"bwDropdown_LwEthOnb\");\n\n            durationDropdown.selectedIndex = 0;\n            bwDropdown.selectedIndex = 0;\n\n            // Clear any status messages\n            document.getElementById(\"statusNet_LwEthOnb\").textContent = \"\";\n            document.getElementById(\"statusNet_LwEthOnbBw\").textContent = \"\";\n\n            // Reset result displays\n            document.getElementById(\"upBW_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"upLat_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"upLostTotal_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"downBW_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"downLat_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"downLostTotal_LwEthOnb\").textContent = \"N/A\";\n\n            if (!triggeredBySync) {\n                localStorage.setItem(\"panelSync\", JSON.stringify({\n                    type: \"reset\"\n                }));\n            }\n        }\n\n        // Function to populate the dropdown for the lower ethernet port on the board\n        function populateDurationDropdownLwEthOnb() {\n            document.getElementById(\"statusNet_LwEthOnb\").textContent = \"\";\n\n            let dropdown = document.getElementById(\"durationDropdown_LwEthOnb\");\n            dropdown.innerHTML = \"\"; // Clear existing options\n\n            let defaultOption = document.createElement(\"option\");\n            defaultOption.value = \"\";\n            defaultOption.textContent = \"Select Duration\";\n            defaultOption.disabled = true;\n            defaultOption.selected = true;\n            dropdown.appendChild(defaultOption);\n\n            for (let i = 5; i <= 60; i += 5) {\n                let option = document.createElement(\"option\");\n                option.value = i; // Store only the numeric value\n                option.textContent = `${i} seconds`;\n                dropdown.appendChild(option);\n            }\n        }\n\n        // Function to handle the change in the dropdown value\n        function setTestDurationLwEthOnb() {\n            document.getElementById(\"statusNet_LwEthOnb\").textContent = \"\";\n            document.getElementById(\"upBW_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"upLat_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"upLostTotal_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"downBW_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"downLat_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"downLostTotal_LwEthOnb\").textContent = \"N/A\";\n\n            const dropdown = document.getElementById(\"durationDropdown_LwEthOnb\");\n            testDurationLwEthOnb = parseInt(dropdown.value, 10);\n            \n            // write to the local storage for synchonization \n            localStorage.setItem(\"panelSync\", JSON.stringify({\n                type: \"duration\",\n                value: dropdown.value\n            }));\n        }\n\n        function populateBwDropdownLwEthOnb() {\n            document.getElementById(\"statusNet_LwEthOnbBw\").textContent = \"\";\n\n            const dropdown = document.getElementById(\"bwDropdown_LwEthOnb\");\n            dropdown.innerHTML = \"\"; // Clear existing options\n\n            // Add the placeholder (disabled and selected by default)\n            const defaultOption = document.createElement(\"option\");\n            defaultOption.value = \"\";\n            defaultOption.textContent = \"Select Bandwidth\";\n            defaultOption.disabled = true;\n            defaultOption.selected = true;\n            dropdown.appendChild(defaultOption);\n\n            // Add real options\n            const bandwidthOptions = [\n                { value: \"10\", text: \"10 Mbits/sec\" },\n                { value: \"100\", text: \"100 Mbits/sec\" },\n                { value: \"1000\", text: \"1000 Mbits/sec\" },\n                // { value: \"2500\", text: \"2500 Mbits/sec\" },\n                // { value: \"5000\", text: \"5000 Mbits/sec\" },\n                // { value: \"10000\", text: \"10000 Mbits/sec\" }\n            ];\n\n            bandwidthOptions.forEach(optionData => {\n                const option = document.createElement(\"option\");\n                option.value = optionData.value;\n                option.textContent = optionData.text;\n                dropdown.appendChild(option);\n            });\n        }\n\n        function setBwLwEthOnb(triggeredBySync = false) {\n            const dropdown = document.getElementById(\"bwDropdown_LwEthOnb\");\n            const selectedBwValue = dropdown.value;\n\n            if (selectedBwValue == \"\") {\n                document.getElementById(\"statusNet_LwEthOnbBw\").textContent = \"\"\n                return\n            }\n            document.getElementById(\"statusNet_LwEthOnb\").textContent = \"\";\n            document.getElementById(\"upBW_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"upLat_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"upLostTotal_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"downBW_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"downLat_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"downLostTotal_LwEthOnb\").textContent = \"N/A\";\n            document.getElementById(\"statusNet_LwEthOnbBw\").innerText = \"Configuring...\";\n\n            if (triggeredBySync) {\n                setTimeout(() => {\n                    document.getElementById(\"statusNet_LwEthOnbBw\").innerText = \"Configuring... Done\";\n                }, 5000);\n            }\n            if (!triggeredBySync) {\n                localStorage.setItem(\"panelSync\", JSON.stringify({\n                    type: \"bandwidth\",\n                    value: selectedBwValue\n                }));\n                fetch(`http://${FLASK_HOST}:${FLASK_PORT}/send_message`, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({ message: `BW:${selectedBwValue}:${FM_INTERFACE_ID}` })\n                })\n                .then(response => {\n                    if (!response.ok) {\n                        throw new Error(\"Configuring... Failed\");\n                    }\n                    // Wait for 5 seconds before updating status\n                    return new Promise(resolve => {\n                        setTimeout(() => resolve(\"Configuring... Done\"), 5000);\n                    });\n                })\n                .then(status => {\n                    document.getElementById(\"statusNet_LwEthOnbBw\").innerText = status;\n                })\n                .catch(error => {\n                    console.error('Error:', error);\n                    document.getElementById(\"statusNet_LwEthOnbBw\").innerText = \"Error sending\";\n                });\n            }\n        }\n\n        function resetBwDropdownToDefaultLwEthOnb() {\n            const dropdown = document.getElementById(\"bwDropdown_LwEthOnb\");\n            // If user leaves dropdown without selecting a valid option, reset\n            if (!dropdown.value) {\n                dropdown.selectedIndex = 0; // fallback to \"Select Bandwidth\"\n            }\n        }\n\n        window.addEventListener(\"storage\", (e) => {\n            if (e.key === \"panelSync\" && e.newValue) {\n                const data = JSON.parse(e.newValue);\n                if (data.type === \"duration\") {\n                    const dropdown = document.getElementById(\"durationDropdown_LwEthOnb\");\n                    dropdown.value = data.value;\n                    testDurationLwEthOnb = parseInt(data.value, 10);\n                }\n                if (data.type === \"bandwidth\") {\n                    const dropdown = document.getElementById(\"bwDropdown_LwEthOnb\");\n                    dropdown.value = data.value;\n                    setBwLwEthOnb(true);\n                }\n                if (data.type === \"run\") {\n                    btnLwEthOnbRunClick(true);\n                }\n                if (data.type === \"reset\") {\n                    btnLwEthOnbResetClick(true);\n                }\n            }\n            if (e.key === \"panelResults\" && e.newValue) {\n                const payload = JSON.parse(e.newValue);\n                if (payload.interface === \"LwEth10GbE\") {\n                    updateResultsLwEthOnb(payload.data);\n                }\n            }\n        });\n    </script>\n</body>\n</html>\n",
        "mode": "html"
      },
      "pluginVersion": "12.1.0",
      "transparent": true,
      "type": "text"
    },
    {
      "datasource": {
        "type": "influxdb",
        "uid": "DS_INFLUXDB"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "palette-classic"
          },
          "custom": {
            "axisBorderShow": false,
            "axisCenteredZero": false,
            "axisColorMode": "text",
            "axisGridShow": true,
            "axisLabel": "",
            "axisPlacement": "auto",
            "barAlignment": 0,
            "barWidthFactor": 0.6,
            "drawStyle": "line",
            "fillOpacity": 20,
            "gradientMode": "opacity",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "insertNulls": false,
            "lineInterpolation": "smooth",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "fieldMinMax": false,
          "mappings": [],
          "thresholds": {
            "mode": "percentage",
            "steps": [
              {
                "color": "green",
                "value": 0
              }
            ]
          },
          "unit": "binBps"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 12,
        "y": 50
      },
      "id": 199,
      "options": {
        "legend": {
          "calcs": [
            "last"
          ],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "hideZeros": false,
          "mode": "multi",
          "sort": "none"
        }
      },
      "pluginVersion": "12.1.0",
      "targets": [
        {
          "alias": "Download",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "A",
          "resultFormat": "logs",
          "select": [
            [
              {
                "params": [
                  "fm1-mac3_download_speed"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        },
        {
          "alias": "Upload",
          "datasource": {
            "type": "influxdb",
            "uid": "DS_INFLUXDB"
          },
          "groupBy": [],
          "hide": false,
          "measurement": "system_metrics",
          "orderByTime": "ASC",
          "policy": "default",
          "refId": "B",
          "resultFormat": "logs",
          "select": [
            [
              {
                "params": [
                  "fm1-mac3_upload_speed"
                ],
                "type": "field"
              }
            ]
          ],
          "tags": []
        }
      ],
      "title": "Throughput",
      "type": "timeseries"
    },
    {
      "gridPos": {
        "h": 4,
        "w": 6,
        "x": 0,
        "y": 54
      },
      "id": 208,
      "options": {
        "code": {
          "language": "plaintext",
          "showLineNumbers": false,
          "showMiniMap": false
        },
        "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Option Selector</title>\n    <style>\n        \n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"dropdown-container\">\n            <div class=\"status-info\">\n                <p><strong>Down Bandwidth:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong> <span id=\"downBW_LwEthOnb\">N/A</span></p>\n                <p><strong>Down Latency:</strong> <span id=\"downLat_LwEthOnb\">N/A</span></p>\n                <p><strong>Down Lost/Total:</strong> <span id=\"downLostTotal_LwEthOnb\">N/A</span></p>\n            </div>\n        </div>\n    </div>\n    <script>\n\n    </script>\n</body>\n</html>\n",
        "mode": "html"
      },
      "pluginVersion": "12.1.0",
      "type": "text"
    },
    {
      "gridPos": {
        "h": 4,
        "w": 6,
        "x": 6,
        "y": 54
      },
      "id": 207,
      "options": {
        "code": {
          "language": "plaintext",
          "showLineNumbers": false,
          "showMiniMap": false
        },
        "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Option Selector</title>\n    <style>\n        \n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"dropdown-container\">\n            <div class=\"status-info\">            \n                <p><strong>Up Bandwidth:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong><span id=\"upBW_LwEthOnb\">N/A</span></p>\n                <p><strong>Up Latency:</strong> <span id=\"upLat_LwEthOnb\">N/A</span></p>\n                <p><strong>Up Lost/Total:</strong> <span id=\"upLostTotal_LwEthOnb\">N/A</span></p>\n            </div>\n        </div>\n    </div>\n    <script>\n\n    </script>\n</body>\n</html>\n",
        "mode": "html"
      },
      "pluginVersion": "12.1.0",
      "type": "text"
    }
  ],
  "refresh": "1s",
  "schemaVersion": 41,
  "tags": [],
  "templating": {
    "list": []
  },
  "time": {
    "from": "now-5m",
    "to": "now"
  },
  "timepicker": {
    "refresh_intervals": [
      "30ms",
      "100ms",
      "500ms",
      "1s",
      "5s",
      "10s",
      "30s",
      "1m",
      "5m",
      "15m",
      "30m",
      "1h",
      "2h",
      "1d"
    ]
  },
  "timezone": "",
  "title": "System Monitor and Control - Topaz - Ship Detection",
  "uid": "debfk50vlpszasd",
  "version": 20,
  "weekStart": ""
}